#!/usr/bin/env bash

DEVELOPERS="VHSgunzo"
RUNIMAGE_VERSION='0.37.2'
RUNROOTFS_VERSION='0.37.2'
RUNSTATIC_VERSION='0.37.2'

RED='\033[1;91m'
BLUE='\033[1;94m'
GREEN='\033[1;92m'
YELLOW='\033[1;33m'
RESETCOLOR='\033[1;00m'

RUNPID="$BASHPID"
RUNKEY="$RANDOM"
SYS_PATH="$PATH"
unset RUNMNT RUNROOTFS SQFUSE BWRAP ARIA2C NOT_TERM \
      MKSQFS NVDRVMNT CAPS NVIDIA_DRIVER_BIND EXEC_STATUS \
      SESSION_MANAGER UNSQFS TMP_BIND SYS_HOME UNPIDS_BIND \
      NETWORK_BIND SETHOMEDIR SETCONFDIR HOME_BIND ARGS_BIND \
      LD_CACHE_BIND ADD_LD_CACHE NEW_HOME TMPDIR_BIND ARGS_BIND \
      SQFUSE_PIDS XDG_RUN_BIND

if [[ -n "$RUNOFFSET" && -n "$ARGV0" ]]
    then
        BINDIR="$RUNDIR/static"
        export PATH="$SYS_PATH:$BINDIR"
        if [ ! -n "$RUNIMAGE" ] # KDE Neon, CachyOS, Puppy Linux bug
            then
                if [ -x "$(realpath "$ARGV0" 2>/dev/null)" ]
                    then
                        export RUNIMAGE="$(realpath "$ARGV0" 2>/dev/null)"
                elif [ -x "$(realpath "$(which "$ARGV0" 2>/dev/null)" 2>/dev/null)" ]
                    then
                        export RUNIMAGE="$(realpath "$(which "$ARGV0" 2>/dev/null)" 2>/dev/null)"
                else
                    export RUNIMAGE="$ARGV0"
                fi
        fi
        if [ -x "$(realpath -s "$ARGV0" 2>/dev/null)" ]
            then
                RUNSRC="$(realpath -s "$ARGV0" 2>/dev/null)"
        elif [ -x "$(realpath -s "$(which "$ARGV0" 2>/dev/null)" 2>/dev/null)" ]
            then
                RUNSRC="$(realpath -s "$(which "$ARGV0" 2>/dev/null)" 2>/dev/null)"
        else
            RUNSRC="$RUNIMAGE"
        fi
        export RUNIMAGEDIR="$(dirname "$RUNIMAGE" 2>/dev/null)"
        RUNIMAGENAME="$(basename "$RUNIMAGE" 2>/dev/null)"
    else
        [ ! -n "$RUNDIR" ] && \
            export RUNDIR="$(dirname "$(realpath "$0" 2>/dev/null)" 2>/dev/null)"
        BINDIR="$RUNDIR/static"
        export PATH="$SYS_PATH:$BINDIR"
        export RUNIMAGEDIR="$(realpath "$RUNDIR/../" 2>/dev/null)"
        if [ -x "$(realpath -s "$0" 2>/dev/null)" ]
            then
                RUNSRC="$(realpath -s "$0" 2>/dev/null)"
        elif [ -x "$(which "$0" 2>/dev/null)" ]
            then
                RUNSRC="$(which "$0" 2>/dev/null)"
        else
            RUNSRC="$RUNDIR/Run"
        fi
fi
RUNSRCNAME="$(basename "$RUNSRC" 2>/dev/null)"

if [[ "$EUID" == 0 && "$ALLOW_ROOT" != 1 ]]
    then
        echo -e "${RED}\t\t\tDo not run runimage as root!"
        echo -e "If you really need to run it as root set the ${YELLOW}ALLOW_ROOT${GREEN}=1 ${RED}environment variable.$RESETCOLOR"
        exit 1
fi

if logname &>/dev/null
    then
        export RUNUSER="$(logname)"
elif [ -n "$SUDO_USER" ]
    then
        export RUNUSER="$SUDO_USER"
elif [[ "$EUID" != 0 && "$USER" != "root" ]] || \
     [[ "$EUID" == 0 && "$USER" != "root" ]]
    then
        export RUNUSER="$USER"
elif [ -n "$(who|grep -m1 'tty'|awk '{print$1}')" ]
    then
        export RUNUSER="$(who|grep -m1 'tty'|awk '{print$1}')"
fi

if [[ "$DISPLAY" == "wayland-"* ]]
    then
        export DISPLAY=":$(echo "$DISPLAY"|sed 's|wayland-||g')"
elif [[ ! -n "$DISPLAY" && ! -n "$WAYLAND_DISPLAY" ]]
    then
        export DISPLAY="$(who|grep "$RUNUSER"|grep -v "ttyS"|\
                          grep -om1 '(.*)$'|sed 's/(//;s/)//')"
fi

xhost +si:localuser:$RUNUSER &>/dev/null
[[ "$EUID" == 0 && "$RUNUSER" != "root" ]] && \
    xhost +si:localuser:root &>/dev/null

[[ ! -n "$LANG" || "$LANG" == "C.UTF8" ]] && \
    export LANG=C

[ "$SYS_TOOLS" == 1 ] && \
    export SYS_MKSQFS=1 SYS_UNSQFS=1 \
           SYS_SQFUSE=1 SYS_BWRAP=1 SYS_ARIA2C=1

[[ "$SYS_MKSQFS" == 1 && -x "$(which mksquashfs 2>/dev/null)" ]] && \
    export MKSQFS="$(which mksquashfs 2>/dev/null)" || \
    export MKSQFS="$BINDIR/mksquashfs"

[[ "$SYS_UNSQFS" == 1 && -x "$(which unsquashfs 2>/dev/null)" ]] && \
    export UNSQFS="$(which unsquashfs 2>/dev/null)" || \
    export UNSQFS="$BINDIR/unsquashfs"

[[ "$SYS_ARIA2C" == 1 && -x "$(which aria2c 2>/dev/null)" ]] && \
    export ARIA2C="$(which aria2c 2>/dev/null)" || \
    export ARIA2C="$BINDIR/aria2c"

if [[ "$SYS_SQFUSE" == 1 && -x "$(which squashfuse 2>/dev/null)" ]]
    then
        export SQFUSE="$(which squashfuse 2>/dev/null)"
else
    [ -x "$(which fusermount3 2>/dev/null)" ] && \
        export SQFUSE="$BINDIR/squashfuse3" || \
        export SQFUSE="$BINDIR/squashfuse"
fi

[ ! -n "$(tty|grep -v 'not a'|grep -Eo 'tty|pts')" ] && \
    NOT_TERM=1

error_msg() {
    echo -e "${RED}[ ERROR ][$(date +"%Y.%m.%d %T")]: $1 $RESETCOLOR"
    if [ "$NOT_TERM" == 1 ]
        then
            notify-send -a 'RunImage Error' "$1" 2>/dev/null &
    fi
}

info_msg() {
    if [ "$QUIET_MODE" != 1 ]
        then
            echo -e "${GREEN}[ INFO ][$(date +"%Y.%m.%d %T")]: $1 $RESETCOLOR"
            if [ "$NOT_TERM" == 1 ]
                then
                    notify-send -a 'RunImage Info' "$1" 2>/dev/null &
            fi
    fi
}

warn_msg() {
    if [ "$QUIET_MODE" != 1 ]
        then
            echo -e "${YELLOW}[ WARNING ][$(date +"%Y.%m.%d %T")]: $1 $RESETCOLOR"
            if [ "$NOT_TERM" == 1 ]
                then
                    notify-send -a 'RunImage Warning' "$1" 2>/dev/null &
            fi
    fi
}

console_info_notify() {
    if [ "$NOT_TERM" == 1 ]
        then
            notify-send -a "RunImage Info" "See the information in the console!" &
        else
            return 1
    fi
}

create_nvidia_driver_image() {
    (if [[ -n "$1" || -n "$nvidia_version" ]]
        then
            [ ! -n "$nvidia_version" ] && \
                nvidia_version="$1"
            [[ -d "$2" && ! -n "$nvidia_drivers_dir" ]] && \
                nvidia_drivers_dir="$2"
            [[ ! -d "$2" && ! -n "$nvidia_drivers_dir" ]] && \
                nvidia_drivers_dir="."
            [ ! -n "$nvidia_driver_image" ] && \
                nvidia_driver_image="$nvidia_version.nv.drv"
            try_mkdir "$nvidia_drivers_dir"
            info_msg "Downloading Nvidia ${nvidia_version} driver, please wait..."
            driver_url="https://us.download.nvidia.com/XFree86/Linux-x86_64/${nvidia_version}/NVIDIA-Linux-x86_64-${nvidia_version}.run"
            if "$ARIA2C" -x 13 -s 13 --allow-overwrite -o "nvidia.run" -d "$nvidia_drivers_dir" "$driver_url"
                then
                    trash_libs="libEGL.so.1.1.0 libGLdispatch.so.0 \
                        libGLESv1_CM.so.1.2.0 libGLESv2.so.2.1.0 libGL.so.1.7.0 \
                        libGLX.so.0 libOpenCL.so.1.0.0 libOpenGL.so.0 \
                        libnvidia-opencl* libnvidia-compiler* libcudadebugger*"
                    chmod u+x "$nvidia_drivers_dir/nvidia.run"
                    info_msg "Unpacking nvidia.run..."
                    (cd "$nvidia_drivers_dir" && \
                        ./nvidia.run -x &>/dev/null
                        rm -f nvidia.run
                        mv -f NVIDIA-Linux-x86_64-${nvidia_version} $nvidia_version)
                    info_msg "Creating a driver directory structure..."
                    (cd "$nvidia_drivers_dir/$nvidia_version" && \
                        rm -rf html kernel* libglvnd_install_checker 32/libglvnd_install_checker \
                            supported-gpus systemd *.gz *.bz2 *.txt *Changelog LICENSE \
                            .manifest *.desktop *.png 2>/dev/null
                        try_mkdir profiles && mv *application-profiles* profiles
                        try_mkdir wine && mv *nvngx.dll wine
                        try_mkdir json && mv *.json json
                        try_mkdir conf && mv *.conf *.icd conf
                        for lib in $trash_libs ; do rm $lib 32/$lib 2>/dev/null ; done
                        try_mkdir bin && mv *.sh mkprecompiled nvidia-cuda-mps-control nvidia-cuda-mps-server \
                            nvidia-debugdump nvidia-installer nvidia-modprobe nvidia-ngx-updater \
                            nvidia-persistenced nvidia-powerd nvidia-settings nvidia-smi nvidia-xconfig bin
                        try_mkdir 64 && mv *.so* 64)
                    info_msg "Creating a squashfs driver image..."
                    info_msg "$nvidia_drivers_dir/$nvidia_driver_image"
                    if "$MKSQFS" "$nvidia_drivers_dir/$nvidia_version" "$nvidia_drivers_dir/$nvidia_driver_image" \
                        -root-owned -no-xattrs -noappend -b 256K -comp lz4 -Xhc -quiet
                        then
                            info_msg "Deleting the source directory of the driver..."
                            rm -rf "$nvidia_drivers_dir/$nvidia_version"
                            return 0
                        else
                            return 1
                    fi
                else
                    error_msg "Failed to download Nvidia driver!"
                    return 1
            fi
        else
            error_msg "You must specify the Nvidia driver version!"
            return 1
    fi)
}

mount_nvidia_driver_image() {
    if [[ -n "$1" && -n "$(echo "$1"|grep -o "\.nv\.drv$")" ]]
        then
            [ ! -n "$nvidia_version" ] && \
                nvidia_version="$(echo "$1"|sed 's|.nv.drv||g')"
            [ ! -n "$NVDRVMNT" ] && \
                NVDRVMNT="/tmp/.mount_nv${nvidia_version}drv.$RUNKEY"
            info_msg "Mounting the Nvidia driver image: $(basename "$1")"
            try_mkdir "$NVDRVMNT"
            "$SQFUSE" -f "$1" "$NVDRVMNT" -o ro &
            SQFUSE_PID="$!"
            sleep 0.05
            [ -d "/proc/$SQFUSE_PID" ] && \
                export SQFUSE_PIDS="$SQFUSE_PID $SQFUSE_PIDS" && \
                nvidia_driver_dir="$NVDRVMNT"
        else
            error_msg "You must specify the Nvidia driver image!"
            return 1
    fi
}

check_nvidia_driver() {
    unset NVIDIA_DRIVER_BIND
    print_nv_drv_dir() { info_msg "Nvidia driver directory found: $(basename "$nvidia_driver_dir")" ; }
    if lsmod|grep nvidia &>/dev/null || nvidia-smi &>/dev/null
        then
            unset nvidia_driver_dir
            nvidia_drivers_dir="$HOME/.local/share/RunImage/nvidia-drivers"
            if modinfo nvidia &>/dev/null
                then
                    nvidia_version="$(modinfo -F version nvidia 2>/dev/null)"
            elif nvidia-smi &>/dev/null
                then
                    nvidia_version="$(nvidia-smi --query-gpu=driver_version --format=csv,noheader|head -1)"
            else
                if [ -d /usr/lib/x86_64-linux-gnu ]
                    then
                        nvidia_version="$(basename /usr/lib/x86_64-linux-gnu/libGLX_nvidia.so.*.*|tail -c +18)"
                    else
                        nvidia_version="$(basename /usr/lib/libGLX_nvidia.so.*.*|tail -c +18)"
                fi
            fi
            if [ -n "$nvidia_version" ]
                then
                    nvidia_version_inside="$(basename "$RUNROOTFS/usr/lib/libGLX_nvidia.so".*.*|tail -c +18)"
                    if [ -n "$nvidia_version_inside" ]
                        then
                            nvidia_driver_image="$nvidia_version.nv.drv"
                            NVDRVMNT="/tmp/.mount_nv${nvidia_version}drv.$RUNKEY"
                            [ "${nvidia_version}" != "${nvidia_version_inside}" ] && \
                            [ "$nvidia_version_inside" != "000.00.00" ] && \
                                warn_msg "Nvidia driver version mismatch detected, trying to fix it"
                            if [ ! -f "$nvidia_drivers_dir/$nvidia_version/64/nvidia_drv.so" ] && \
                               [ ! -f "$RUNIMAGEDIR/$nvidia_driver_image" ] && \
                               [ ! -f "$nvidia_drivers_dir/$nvidia_driver_image" ] && \
                               [ ! -f "$NVDRVMNT/64/nvidia_drv.so" ] && \
                               [ "${nvidia_version}" != "${nvidia_version_inside}" ]
                                then
                                    if create_nvidia_driver_image
                                        then
                                            mount_nvidia_driver_image "$nvidia_drivers_dir/$nvidia_driver_image"
                                        else
                                            nvidia_driver_dir="$nvidia_drivers_dir/$nvidia_version"
                                    fi
                                else
                                    if [ -f "$NVDRVMNT/64/nvidia_drv.so" ]
                                        then
                                            nvidia_driver_dir="$NVDRVMNT"
                                            print_nv_drv_dir
                                    elif [ -f "$nvidia_drivers_dir/$nvidia_version/64/nvidia_drv.so" ]
                                        then
                                            nvidia_driver_dir="$nvidia_drivers_dir/$nvidia_version"
                                            print_nv_drv_dir
                                    elif [ -f "$RUNIMAGEDIR/$nvidia_driver_image" ]
                                        then
                                            mount_nvidia_driver_image "$RUNIMAGEDIR/$nvidia_driver_image"
                                    elif [ -f "$nvidia_drivers_dir/$nvidia_driver_image" ]
                                        then
                                            mount_nvidia_driver_image "$nvidia_drivers_dir/$nvidia_driver_image"
                                    fi
                            fi
                        else
                            error_msg "No Nvidia driver found inside the RunImage!"
                            return 1
                    fi
                    if [ -f "$nvidia_driver_dir/64/nvidia_drv.so" ]
                        then
                            nvidia_libs_list="libcuda.so libEGL_nvidia.so libGLESv1_CM_nvidia.so \
                                libGLESv2_nvidia.so libGLX_nvidia.so libnvcuvid.so libnvidia-allocator.so \
                                libnvidia-cfg.so libnvidia-eglcore.so libnvidia-encode.so libnvidia-fbc.so \
                                libnvidia-glcore.so libnvidia-glsi.so libnvidia-glvkspirv.so libnvidia-ml.so \
                                libnvidia-ngx.so libnvidia-opticalflow.so libnvidia-ptxjitcompiler.so \
                                libnvidia-rtcore.so libnvidia-tls.so libnvidia-vulkan-producer.so libnvoptix.so"
                            for lib in ${nvidia_libs_list}
                                do
                                    if [ -f "$RUNROOTFS/usr/lib/${lib}.${nvidia_version_inside}" ]
                                        then
                                            NVIDIA_DRIVER_BIND+=("--ro-bind-try" \
                                                "$nvidia_driver_dir/64/${lib}.${nvidia_version}" \
                                                "/usr/lib/${lib}.${nvidia_version_inside}")
                                    fi
                                    if [ -f "$RUNROOTFS/usr/lib32/${lib}.${nvidia_version_inside}" ]
                                        then
                                            NVIDIA_DRIVER_BIND+=("--ro-bind-try" \
                                                "$nvidia_driver_dir/32/${lib}.${nvidia_version}" \
                                                "/usr/lib32/${lib}.${nvidia_version_inside}")
                                    fi
                            done
                            if [ -f "$RUNROOTFS/usr/lib/firmware/nvidia/${nvidia_version_inside}/gsp.bin" ]
                                then
                                    NVIDIA_DRIVER_BIND+=("--ro-bind-try" \
                                        "$nvidia_driver_dir/firmware/gsp.bin" \
                                        "/usr/lib/firmware/nvidia/${nvidia_version_inside}/gsp.bin")
                            fi
                            if [ -f "$RUNROOTFS/usr/lib/libnvidia-egl-gbm.so.1.1.0" ]
                                then
                                    NVIDIA_DRIVER_BIND+=("--ro-bind-try" \
                                        "$nvidia_driver_dir/64/libnvidia-egl-gbm.so.1.1.0" \
                                        "/usr/lib/libnvidia-egl-gbm.so.1.1.0")
                            fi
                            if [ -f "$RUNROOTFS/usr/lib/nvidia/xorg/libglxserver_nvidia.so.${nvidia_version_inside}" ]
                                then
                                    NVIDIA_DRIVER_BIND+=("--ro-bind-try" \
                                        "$nvidia_driver_dir/64/libglxserver_nvidia.so.${nvidia_version}" \
                                        "/usr/lib/nvidia/xorg/libglxserver_nvidia.so.${nvidia_version_inside}")
                            fi
                            if [ -f "$RUNROOTFS/usr/lib/vdpau/libvdpau_nvidia.so.${nvidia_version_inside}" ]
                                then
                                    NVIDIA_DRIVER_BIND+=("--ro-bind-try" \
                                        "$nvidia_driver_dir/64/libvdpau_nvidia.so.${nvidia_version}" \
                                        "/usr/lib/vdpau/libvdpau_nvidia.so.${nvidia_version_inside}")
                            fi
                            if [ -f "$RUNROOTFS/usr/lib32/vdpau/libvdpau_nvidia.so.${nvidia_version_inside}" ]
                                then
                                    NVIDIA_DRIVER_BIND+=("--ro-bind-try" \
                                        "$nvidia_driver_dir/32/libvdpau_nvidia.so.${nvidia_version}" \
                                        "/usr/lib32/vdpau/libvdpau_nvidia.so.${nvidia_version_inside}")
                            fi
                            if [ -f "$RUNROOTFS/usr/lib/xorg/modules/drivers/nvidia_drv.so" ]
                                then
                                    NVIDIA_DRIVER_BIND+=("--ro-bind-try" \
                                        "$nvidia_driver_dir/64/nvidia_drv.so" \
                                        "/usr/lib/xorg/modules/drivers/nvidia_drv.so")
                            fi
                            if [ -f "$RUNROOTFS/usr/share/egl/egl_external_platform.d/15_nvidia_gbm.json" ]
                                then
                                    NVIDIA_DRIVER_BIND+=("--ro-bind-try" \
                                        "$nvidia_driver_dir/json/15_nvidia_gbm.json" \
                                        "/usr/share/egl/egl_external_platform.d/15_nvidia_gbm.json")
                            fi
                            if [ -f "$RUNROOTFS/usr/share/glvnd/egl_vendor.d/10_nvidia.json" ]
                                then
                                    NVIDIA_DRIVER_BIND+=("--ro-bind-try" \
                                        "$nvidia_driver_dir/json/10_nvidia.json" \
                                        "/usr/share/glvnd/egl_vendor.d/10_nvidia.json")
                            fi
                            if [ -f "$RUNROOTFS/usr/share/vulkan/icd.d/nvidia_icd.json" ]
                                then
                                    NVIDIA_DRIVER_BIND+=("--ro-bind-try" \
                                        "$nvidia_driver_dir/json/nvidia_icd.json" \
                                        "/usr/share/vulkan/icd.d/nvidia_icd.json")
                            fi
                            if [ -f "$RUNROOTFS/usr/share/vulkan/implicit_layer.d/nvidia_layers.json" ]
                                then
                                    NVIDIA_DRIVER_BIND+=("--ro-bind-try" \
                                        "$nvidia_driver_dir/json/nvidia_layers.json" \
                                        "/usr/share/vulkan/implicit_layer.d/nvidia_layers.json")
                            fi
                            if [ -d "$RUNROOTFS/usr/share/nvidia" ]
                                then
                                    NVIDIA_DRIVER_BIND+=("--ro-bind-try" \
                                        "$nvidia_driver_dir/profiles" \
                                        "/usr/share/nvidia")
                            fi
                            if [ -d "$RUNROOTFS/usr/lib/nvidia/wine" ]
                                then
                                    NVIDIA_DRIVER_BIND+=("--ro-bind-try" \
                                        "$nvidia_driver_dir/wine" \
                                        "/usr/lib/nvidia/wine")
                            fi
                            NVIDIA_DRIVER_BIND+=("--ro-bind-try" "$nvidia_driver_dir/bin" "/usr/bin/nvidia" \
                                "--ro-bind-try" "$nvidia_driver_dir/64" "/usr/lib/nvidia/64" \
                                "--ro-bind-try" "$nvidia_driver_dir/32" "/usr/lib/nvidia/32")
                            add_bin_pth '/usr/bin/nvidia'
                            add_lib_pth '/usr/lib/nvidia/64:/usr/lib/nvidia/32'
                            if [ "$(cat "$HOME/.local/share/RunImage/ld.so.version" 2>/dev/null)" != "$RUNROOTFS_VERSION-$nvidia_version" ]
                                then
                                    info_msg "Updating the nvidia library cache..."
                                    if (NO_NVIDIA_CHECK=1 ; QUIET_MODE=1 ; bwrun \
                                        /usr/bin/ldconfig -C "/tmp/ld.so.cache" 2>/dev/null)
                                        then
                                            try_mkdir "$HOME/.local/share/RunImage"
                                            if mv -f "/tmp/ld.so.cache" \
                                                "$HOME/.local/share/RunImage/ld.so.cache" 2>/dev/null
                                                then
                                                    echo "$RUNROOTFS_VERSION-$nvidia_version" > \
                                                        "$HOME/.local/share/RunImage/ld.so.version"
                                                    ADD_LD_CACHE=1
                                                else
                                                    error_msg "Failed to merge nvidia library cache!"
                                            fi
                                        else
                                            error_msg "Failed to update nvidia library cache!"
                                    fi
                                else
                                    ADD_LD_CACHE=1
                            fi
                    fi
            fi
    fi
}

add_lib_pth() {
    if [ -n "$LIB_PATH" ]
        then
            if [ ! -n "$(echo "$LIB_PATH"|grep -ow "$1" 2>/dev/null)" ]
                then
                    LIB_PATH="${1}:${LIB_PATH}"
            fi
        else
            LIB_PATH="${1}"
    fi
}

add_bin_pth() {
    if [ -n "$BIN_PATH" ]
        then
            if [ ! -n "$(echo "$BIN_PATH"|grep -ow "$1" 2>/dev/null)" ]
                then
                    BIN_PATH="${1}:${BIN_PATH}"
            fi
        else
            BIN_PATH="${1}"
    fi
}

try_unmount() {
    if [ -d "$1" ]
        then
            unset DORM
            if fusermount -uz "$1" 2>/dev/null
                then DORM=1
            elif umount -l "$1" 2>/dev/null
                then DORM=1
            elif kill $SQFUSE_PIDS 2>/dev/null
                then DORM=1
            fi
            [ "$DORM" == 1 ] && \
                rm -rf "$1" 2>/dev/null
    fi
}

try_mkdir() {
    if [ ! -d "$1" ]
        then
            if ! mkdir -p "$1"
                then
                    error_msg "Failed to create directory '$1'"
                    FORCE_CLEANUP=1 cleanup
                    exit 1
            fi
    fi
}

cleanup() {
    if [[ "$NO_CLEANUP" != 1 || "$FORCE_CLEANUP" == 1 ]]
        then
            if [ -n "$SQFUSE_PIDS" ]
                then
                    try_unmount "$RUNMNT"
                    try_unmount "$NVDRVMNT"
                    if [ "$FORCE_CLEANUP" == 1 ]
                        then
                            ALLPIDS="$(lsof -n "$RUNDIR" 2>/dev/null|sed 1d|\
                                        grep -v "$RUNPID"|awk '{print$2}'|sort -u)"
                            [ -n "$ALLPIDS" ] && \
                                kill -9 $ALLPIDS 2>/dev/null
                        else
                            kill $SQFUSE_PIDS 2>/dev/null
                    fi
            fi
        else
            warn_msg "Cleanup is disabled!"
    fi
}

bwrun() {
    unset CAPS
    [[ "$SYS_BWRAP" == 1 && -x "$(which bwrap 2>/dev/null)" ]] && \
        export BWRAP="$(which bwrap 2>/dev/null)" || \
        export BWRAP="$BINDIR/bwrap"
    if [[ -x "$(find "$BWRAP" -perm -u=s 2>/dev/null)" && \
        "$SYS_BWRAP" == 1 && "$EUID" != 0 ]] || [ "$NO_CAP" == 1 ]
        then
            warn_msg "Bubblewrap capabilities is disabled!"
        else
            CAPS+=("--cap-add" "ALL")
            CAPS+=("--cap-drop" "CAP_SYS_NICE") # Gamecope bug https://github.com/Plagman/gamescope/issues/309
    fi
    [ "$NO_NVIDIA_CHECK" != 1 ] && \
        check_nvidia_driver || \
        warn_msg "Nvidia driver check is disabled!"
    [ "$ADD_LD_CACHE" == 1 ] && \
        LD_CACHE_BIND=("--bind-try" \
            "$HOME/.local/share/RunImage/ld.so.cache" "/etc/ld.so.cache")
    [ ! -n "$XORG_CONF" ] && \
        XORG_CONF="/etc/X11/xorg.conf"

    "$BWRAP" --bind-try "$RUNROOTFS" / \
        --proc /proc \
        --tmpfs /var/log \
        --die-with-parent \
        --bind-try /sys /sys \
        --bind-try /mnt /mnt \
        --bind-try /tmp /tmp \
        --bind-try /boot /boot \
        --dev-bind-try /dev /dev \
        --bind-try /media /media \
        --bind-try /var/tmp /var/tmp \
        --bind-try /var/mnt /var/mnt \
        --bind-try /var/opt /var/opt \
        --bind-try /var/home /var/home \
        --bind-try /var/empty /var/empty \
        --bind-try /var/local /var/local \
        --bind-try /var/games /var/games \
        --ro-bind-try /etc/group /etc/group \
        --bind-try /lib/modules /lib/modules \
        --ro-bind-try /etc/passwd /etc/passwd \
        --bind-try /var/roothome /var/roothome \
        --ro-bind-try /etc/hostname /etc/hostname \
        --ro-bind-try /etc/localtime /etc/localtime \
        --ro-bind-try /etc/machine-id /etc/machine-id \
        --ro-bind-try /etc/nsswitch.conf /etc/nsswitch.conf \
        --ro-bind-try "$XORG_CONF" /etc/X11/xorg.conf \
        "${NVIDIA_DRIVER_BIND[@]}" "${TMP_BIND[@]}" \
        "${CAPS[@]}" "${HOME_BIND[@]}" "${NETWORK_BIND[@]}" \
        "${XDG_RUN_BIND[@]}" "${LD_CACHE_BIND[@]}" \
        "${TMPDIR_BIND[@]}" "${UNPIDS_BIND[@]}" \
        --setenv PATH "$BIN_PATH" \
        --setenv LD_LIBRARY_PATH "$LIB_PATH" \
        --setenv NO_AT_BRIDGE '1' \
        --setenv GDK_BACKEND 'x11' \
        --setenv SHELL '/usr/bin/fish' \
        --setenv DESKTOP_SESSION 'xfce' \
        --setenv ZDOTDIR '/etc/zsh/zshrc' \
        --setenv GTK_THEME 'Adwaita:dark' \
        --setenv XDG_CURRENT_DESKTOP 'XFCE' \
        --setenv QT_QPA_PLATFORMTHEME 'qt5ct' \
        --setenv GTK2_RC_FILES '/usr/share/gtk-2.0/gtkrc' \
        --setenv XDG_CONFIG_DIRS "/etc/xdg:$XDG_CONFIG_DIRS" \
        --setenv XDG_DATA_DIRS "/usr/local/share:/usr/share:$XDG_DATA_DIRS" \
        "${ARGS_BIND[@]}" \
        "$@"
    return $?
}

pkglist() { NO_NVIDIA_CHECK=1 QUIET_MODE=1 bwrun /usr/bin/pacman -Q 2>/dev/null ; }

binlist() { NO_NVIDIA_CHECK=1 QUIET_MODE=1 bwrun /usr/bin/find /usr/bin/ \
            -executable -type f -maxdepth 1 2>/dev/null|sed 's|/usr/bin/||g' ; }

bwraphelp() { NO_NVIDIA_CHECK=1 QUIET_MODE=1 bwrun --help ; }

print_help() {
if ! console_info_notify
    then
    echo -e "
    ${GREEN}RuntimeImage ${RED}v${RUNIMAGE_VERSION} ${GREEN}by $DEVELOPERS
        ${RED}Usage:
            $RED┌──[$GREEN$RUNUSER$YELLOW@$BLUE$(uname -a|awk '{print$2}')$RED]─[$GREEN$PWD$RED]
            $RED└──╼ \$$GREEN $([ -n "$RUNIMAGE" ] && echo "$RUNIMAGE"||echo "$0") {executable} $YELLOW{arguments}

            ${BLUE}--runimage-help$GREEN                      Show this usage info
            ${BLUE}--runimage-bwraphelp$GREEN                 Show Bubblewrap usage info
            ${BLUE}--runimage-version$GREEN                   Show the runimage version
            ${BLUE}--runimage-pkglist$GREEN                   Show packages installed in runimage
            ${BLUE}--runimage-binlist$GREEN                   Show /usr/bin in runimage
            ${BLUE}--runimage-shell$YELLOW {args}$GREEN              Run the runimage shell or execute a command in runimage shell

        ${RED}Only for not extracted:
            ${BLUE}--runtime-extract$YELLOW {pattern}$GREEN          Extract content from embedded filesystem image
            ${BLUE}--runtime-extract-and-run $YELLOW{args}$GREEN     Run the runimage afer extraction without using FUSE
            ${BLUE}--runtime-help$GREEN                       Show runimage runtime help (Shown in this help)
            ${BLUE}--runtime-mount$GREEN                      Mount embedded filesystem image and print
            ${BLUE}--runtime-offset$GREEN                     Print byte offset to start of embedded
            ${BLUE}--runtime-portable-home$GREEN              Create a portable home folder to use as ${YELLOW}\$HOME$GREEN
            ${BLUE}--runtime-portable-config$GREEN            Create a portable config folder to use as ${YELLOW}\$XDG_CONFIG_HOME$GREEN
            ${BLUE}--runtime-version$GREEN                    Print version of runimage runtime

        ${RED}Environment variables:
            ${YELLOW}NO_INET$GREEN=1                            Disables network access
            ${YELLOW}TMP_HOME$GREEN=1                           Creates tmpfs /home/\$USER and /root in RAM and uses it as ${YELLOW}\$HOME
            ${YELLOW}TMP_HOME_DL$GREEN=1                        As above, but with binding ${YELLOW}\$HOME${GREEN}/Downloads directory
            ${YELLOW}PORTABLE_HOME$GREEN=1                      Creates a portable home folder and uses it as ${YELLOW}\$HOME
            ${YELLOW}PORTABLE_CONFIG$GREEN=1                    Creates a portable config folder and uses it as ${YELLOW}\$XDG_CONFIG_HOME
            ${YELLOW}NO_CLEANUP$GREEN=1                         Disables unmounting and cleanup mountpoints
            ${YELLOW}FORCE_CLEANUP$GREEN=1                      Kills all runimage background processes when exiting
            ${YELLOW}NO_NVIDIA_CHECK$GREEN=1                    Disables checking the nvidia driver version
            ${YELLOW}NO_CAP$GREEN=1                             Disables Bubblewrap capabilities (Default: ALL, drop CAP_SYS_NICE)
            ${YELLOW}AUTORUN$GREEN=\"{executable} {args}\"        Run the runimage with autorun options for /usr/bin executables
            ${YELLOW}ALLOW_ROOT$GREEN=1                         Allows to run runimage under root user
            ${YELLOW}QUIET_MODE$GREEN=1                         Disables all non-error runimage messages

            ${YELLOW}SYS_BWRAP$GREEN=1                          Using system ${BLUE}bwrap
            ${YELLOW}SYS_SQFUSE$GREEN=1                         Using system ${BLUE}squashfuse
            ${YELLOW}SYS_ARIA2C$GREEN=1                         Using system ${BLUE}aria2c
            ${YELLOW}SYS_UNSQFS$GREEN=1                         Using system ${BLUE}unsquashfs
            ${YELLOW}SYS_MKSQFS$GREEN=1                         Using system ${BLUE}mksquashfs
            ${YELLOW}SYS_TOOLS$GREEN=1                          Using all these binaries from the system
                                                 If they are not found in the system - auto return to the built-in

        ${RED}Additional information:${GREEN}
            You can create a symlink/hardlink to the runimage or rename runimage and give it the name
              of some executable file from /usr/bin inside the runimage, this will allow you to run
              the runimage in autorun mode for this executable file.
            The same principle applies to the ${YELLOW}AUTORUN$GREEN variable:
              $RED┌──[$GREEN$RUNUSER$YELLOW@$BLUE$(uname -a|awk '{print$2}')$RED]─[$GREEN$PWD$RED]
              $RED└──╼ \$ ${GREEN}export ${YELLOW}AUTORUN=\"ls -la\"
              $RED└──╼ \$ ${GREEN}runimage ${YELLOW}{args}${GREEN}
              Here runimage will become something like an alias for 'ls' inside the runimage
                with the '-la' argument.
            This will also work in extracted form for the Run script.

            When using the ${YELLOW}PORTABLE_HOME$GREEN and ${YELLOW}PORTABLE_CONFIG$GREEN variables, runimage will create or
              search for these directories next to itself. The same behavior will occur when
              adding a runimage or Run script or renamed or symlink/hardlink to them in the PATH
                it can be used both extracted and compressed:
                  ${YELLOW}'$RUNIMAGEDIR/Run.home'
                  ${YELLOW}'$RUNIMAGEDIR/Run.config'$GREEN
                if symlink/hardlink are used:
                  ${YELLOW}'$RUNIMAGEDIR/{symlink/hardlink_name}.home'
                  ${YELLOW}'$RUNIMAGEDIR/{symlink/hardlink_name}.config'$GREEN
                or with the runimage/Run name:
                  ${YELLOW}'$RUNIMAGEDIR/{runimage/Run_name}.home'
                  ${YELLOW}'$RUNIMAGEDIR/{runimage/Run_name}.config'$GREEN

            Runimage uses fakeroot and fakechroot, which allows you to use root commands, including in
              unpacked form, to update the rootfs or install/remove packages. Sudo and pkexec have
              also been replaced with fake ones.

        ${RED}For Nvidia users with a proprietary driver:${GREEN}
            If the nvidia driver version does not match inside runimage and in the host, runimage
              will make an image with the nvidia driver of the required version. (requires internet)
            Inside runimage, a fake version of the nvidia driver is installed by default to reduce
              the size, so for nvidia users, an image of the nvidia driver will be automatically
              created and further used as an additional module to runimage.
            But you can also install the usual nvidia driver of your version in runimage.
            Checking the nvidia driver version can be disabled using ${YELLOW}NO_NVIDIA_CHECK$GREEN variable.
              the nvidia driver image can be located next to the runimage:
                ${YELLOW}'$RUNIMAGEDIR/{nvidia_version}.nv.drv'$GREEN
              or in ${YELLOW}\$HOME$GREEN (Default):
                ${YELLOW}'\$HOME/.local/share/RunImage/nvidia-drivers/{nvidia_version}.nv.drv'$GREEN
              also, the driver can be extracted as the directory
                ${YELLOW}'\$HOME/.local/share/RunImage/nvidia-drivers/{nvidia_version}'

        ${RED}Recommendations:${GREEN}
            If the kernel does not support user namespaces, you need to install
              SUID Bubblewrap into the system, or install a kernel with user namespaces support.
            If you use SUID Bubblewrap, then you will encounter some limitations, such as the inability to use
              FUSE inside the container, without running it under the root user, because the capabilities are
              disabled, and so on. So it would be better for you to install kernel with
              user namespaces support.
            I recommend installing the XanMod kernel (${BLUE}https://xanmod.org${GREEN}), because I noticed that the speed
              of runimage in compressed form on this kernel is much higher due to more correct caching settings
              and special patches.
        $RESETCOLOR" >&2
fi
}

if [ "$EUID" != 0 ]
    then
        if [ ! -f '/proc/self/ns/user' ]
            then
                SYS_BWRAP=1
                [ ! -n "$(echo "$PATH"|grep -wo '^/usr/bin:')" ] && \
                    export PATH="/usr/bin:$PATH"
                if [ ! -x "$(find "$(which bwrap 2>/dev/null)" -perm -u=s 2>/dev/null)" ]
                    then
                        [ ! -x '/tmp/bwrap' ] && \
                            rm -rf '/tmp/bwrap' && \
                            cp "$BINDIR/bwrap" '/tmp/'
                        error_msg 'The kernel does not support user namespaces!'
                        if ! console_info_notify
                            then
                                echo -e "${YELLOW}\nYou need to install SUID Bubblewrap into the system:"
                                echo -e "${RED}# ${GREEN}sudo cp -f /tmp/bwrap /usr/bin/ && sudo chmod u+s /usr/bin/bwrap"
                                echo -e "${RED}\n[NOT RECOMMENDED]: ${YELLOW}Or run as the root user."
                                echo -e "${YELLOW}\nOr install a kernel with user namespaces support."
                                echo -e "[RECOMMENDED]: XanMod kernel -> ${BLUE}https://xanmod.org$RESETCOLOR"
                        fi
                        exit 1
                fi
        elif [ "$(cat '/proc/sys/kernel/unprivileged_userns_clone' 2>/dev/null)" == 0 ]
            then
                error_msg "unprivileged_userns_clone is disabled!"
                if ! console_info_notify
                    then
                        echo -e "${YELLOW}\nYou need to enable unprivileged_userns_clone:"
                        echo -e "${RED}# ${GREEN}sudo bash -c 'echo kernel.unprivileged_userns_clone=1 >> /etc/sysctl.d/98-userns.conf'"
                        echo -e "${RED}# ${GREEN}sudo bash -c 'echo 1 > /proc/sys/kernel/unprivileged_userns_clone'$RESETCOLOR"
                fi
                exit 1
        elif [ "$(cat '/proc/sys/user/max_user_namespaces' 2>/dev/null)" == 0 ]
            then
                error_msg "max_user_namespaces is disabled!"
                if ! console_info_notify
                    then
                        echo -e "${YELLOW}\nYou need to enable max_user_namespaces:"
                        echo -e "${RED}# ${GREEN}sudo bash -c 'echo user.max_user_namespaces=10000 >> /etc/sysctl.d/98-userns.conf'"
                        echo -e "${RED}# ${GREEN}sudo bash -c 'echo 10000 > /proc/sys/user/max_user_namespaces'$RESETCOLOR"
                fi
                exit 1
        elif [ "$(cat '/proc/sys/kernel/userns_restrict' 2>/dev/null)" == 1 ]
            then
                error_msg "userns_restrict is enabled!"
                if ! console_info_notify
                    then
                        echo -e "${YELLOW}\nYou need to disabled userns_restrict:"
                        echo -e "${RED}# ${GREEN}sudo bash -c 'echo kernel.userns_restrict=0 >> /etc/sysctl.d/98-userns.conf'"
                        echo -e "${RED}# ${GREEN}sudo bash -c 'echo 0 > /proc/sys/kernel/userns_restrict'$RESETCOLOR"
                fi
                exit 1
        fi
fi

if sestatus &>/dev/null
    then
        [ "$(sestatus|grep mode|awk '{print$3}')" == "enforcing" ] && \
            warn_msg "SELinux in enforcing mode!"
fi

if [[ -n "$RUNOFFSET" && -n "$RUNIMAGE" ]] # MangoHud and vkBasalt bug in DXVK mode
    then
        export RUNMNT="/tmp/.mount_${RUNIMAGENAME}.$RUNKEY"
        export RUNROOTFS="$RUNMNT/rootfs"
        try_mkdir "$RUNMNT"
        "$SQFUSE" -f "$RUNIMAGE" "$RUNMNT" -o "ro,offset=$RUNOFFSET" &
        SQFUSE_PID="$!"
        sleep 0.05
        [ -d "/proc/$SQFUSE_PID" ] && \
            export SQFUSE_PIDS="$SQFUSE_PID $SQFUSE_PIDS"
    else
        export RUNROOTFS="$RUNDIR/rootfs"
fi

if [ "$RUNSRCNAME" == "lwrun" ]
    then
        AUTORUN="lutris-wine"
elif [[ "$RUNSRCNAME" != "Run"* && \
        "$RUNSRCNAME" != "runimage"* ]]
   then
        AUTORUN="$RUNSRCNAME"
fi

if [ -n "$AUTORUN" ]
    then
        AUTORUN0ARG=($AUTORUN)
        info_msg "Autorun mode: $AUTORUN"
        if [ ! -x "$RUNROOTFS/usr/bin/$AUTORUN0ARG" ]
            then
                error_msg "$AUTORUN0ARG not found in /usr/bin"
                FORCE_CLEANUP=1 cleanup
                exit 1
        fi
fi

[ -n "$HOME" ] && \
   SYS_HOME="$HOME"

if [[ "$TMP_HOME" == 1 || "$TMP_HOME_DL" == 1 ]]
    then
        [ "$EUID" == 0 ] && \
            export HOME="/root" || \
            export HOME="/home/$RUNUSER"
        HOME_BIND+=("--tmpfs" "/home" \
                    "--tmpfs" "/root" \
                    "--dir" "$HOME/.cache" \
                    "--dir" "$HOME/.config" \
                    "--dir" "$HOME/.local/share/RunImage")
        [[ "$EUID" == 0 && "$RUNUSER" != "root" ]] && \
            HOME_BIND+=("--dir" "/home/$RUNUSER")
        [ "$TMP_HOME_DL" == 1 ] && \
            HOME_BIND+=("--dir" "$HOME/Downloads" \
                        "--symlink" "$HOME/Downloads" "$HOME/Загрузки" \
                        "--bind-try" "$HOME/Downloads" "$HOME/Downloads")
        info_msg "Setting temporary \$HOME to '$HOME'"
    else
        if [[ -n "$SYS_HOME" && "$SYS_HOME" != "/root" && \
            "$(echo "$SYS_HOME"|head -c 6)" != "/home/" ]]
            then
                case "$(echo "$SYS_HOME"|cut -d '/' -f2)" in
                    tmp|mnt|media|run|dev|proc|sys) : ;;
                    *)
                        if [ "$EUID" == 0 ]
                            then
                                NEW_HOME="/root"
                                HOME_BIND+=("--bind-try" "/home" "/home")
                            else
                                NEW_HOME="/home/$RUNUSER"
                                HOME_BIND+=("--tmpfs" "/home" \
                                            "--tmpfs" "/root" \
                                            "--dir" "$NEW_HOME")
                        fi
                        HOME_BIND+=("--bind-try" "$SYS_HOME" "$NEW_HOME")
                        export HOME="$NEW_HOME"
                    ;;
                esac
            else
                HOME_BIND+=("--bind-try" "/home" "/home")
                if [ "$EUID" == 0 ]
                    then
                        if [ "$SYS_HOME" == "/home/$RUNUSER" ]
                            then
                                export HOME="/root"
                                SETHOMEDIR=1
                        fi
                        HOME_BIND+=("--bind-try" "/root" "/root")
                    else
                        HOME_BIND+=("--tmpfs" "/root")
                fi
        fi
fi

if [[ "$PORTABLE_HOME" == 1 || ! -n "$HOME" || -d "$RUNIMAGEDIR/$RUNSRCNAME.home" ]] && \
    [[ "$PORTABLE_HOME" != 0 && "$TMP_HOME" != 1 && "$TMP_HOME_DL" != 1 ]]
    then
        export HOME="$RUNIMAGEDIR/$RUNSRCNAME.home"
        SETHOMEDIR=1
elif [[ -n "$RUNIMAGE" && "$PORTABLE_HOME" != 0 && "$TMP_HOME" != 1 && "$TMP_HOME_DL" != 1 ]] && \
    [[ "$PORTABLE_HOME" == 1 || -d "$RUNIMAGE.home" ]]
    then
        export HOME="$RUNIMAGE.home"
        SETHOMEDIR=1
elif [[ "$PORTABLE_HOME" == 1 || -d "$RUNIMAGEDIR/Run.home" ]] && \
    [[ "$PORTABLE_HOME" != 0 && "$TMP_HOME" != 1 && "$TMP_HOME_DL" != 1 ]]
    then
        export HOME="$RUNIMAGEDIR/Run.home"
        SETHOMEDIR=1
fi
if [[ -L "$HOME" && ! -n "$NEW_HOME" && "$HOME" != "/root" ]]
    then
        export HOME="$(realpath "$HOME" 2>/dev/null)"
        warn_msg "Symlinking for \$HOME is not allowed!"
        SETHOMEDIR=1
fi
if [ "$SETHOMEDIR" == 1 ]
    then
        try_mkdir "$HOME"
        try_mkdir "$HOME/.cache"
        try_mkdir "$HOME/.config"
        info_msg "Setting \$HOME to '$HOME'"
fi

if [[ "$PORTABLE_CONFIG" == 1 || -d "$RUNIMAGEDIR/$RUNSRCNAME.config" ]] && \
    [ "$PORTABLE_CONFIG" != 0 ]
    then
        export XDG_CONFIG_HOME="$RUNIMAGEDIR/$RUNSRCNAME.config"
        SETCONFDIR=1
elif [[ -n "$RUNIMAGE" && "$PORTABLE_CONFIG" != 0 ]] && \
    [[ "$PORTABLE_CONFIG" == 1 || -d "$RUNIMAGE.config" ]]
    then
        export XDG_CONFIG_HOME="$RUNIMAGE.config"
        SETCONFDIR=1
elif [[ "$PORTABLE_CONFIG" == 1 || -d "$RUNIMAGEDIR/Run.config" ]] && \
    [ "$PORTABLE_CONFIG" != 0 ]
    then
        export XDG_CONFIG_HOME="$RUNIMAGEDIR/Run.config"
        SETCONFDIR=1
fi
if [ "$SETCONFDIR" == 1 ]
    then
        try_mkdir "$XDG_CONFIG_HOME"
        info_msg "Setting \$XDG_CONFIG_HOME to '$XDG_CONFIG_HOME'"
fi

[ -n "$XAUTHORITY" ] && \
    SYS_XAUTHORITY="$XAUTHORITY"

if [[ ! -n "$XAUTHORITY" || "$SETHOMEDIR" == 1 || \
    "$TMP_HOME" == 1 || "$TMP_HOME_DL" == 1 ]]
    then
        export XAUTHORITY="$HOME/.Xauthority"
        if [ -n "$SYS_XAUTHORITY" ]
            then
                HOME_BIND+=("--bind-try" "$SYS_XAUTHORITY" "$XAUTHORITY")
            else
                if [[ "$EUID" == 0 && "$RUNUSER" == "root" ]]
                    then
                        HOME_BIND+=("--bind-try" "/root/.Xauthority" "$XAUTHORITY")
                elif [[ "$EUID" == 0 && "$RUNUSER" != "root" ]]
                    then
                        HOME_BIND+=("--ro-bind-try" "/home/$RUNUSER/.Xauthority" "$XAUTHORITY")
                else
                    HOME_BIND+=("--bind-try" "/home/$RUNUSER/.Xauthority" "$XAUTHORITY")
                fi
        fi
fi

if [[ ! -n "$XDG_RUNTIME_DIR" || "$XDG_RUNTIME_DIR" != "/run/user/$EUID" || "$UNSHARE_PIDS" == 1 ]]
    then
        export XDG_RUNTIME_DIR="/run/user/$EUID"
        if [[ "$UNSHARE_PIDS" == 1 || ! -d "$XDG_RUNTIME_DIR" ]]
            then
                XDG_RUN_BIND+=("--tmpfs" "/run" \
                               "--dir" "$XDG_RUNTIME_DIR" \
                               "--chmod" "0700" "$XDG_RUNTIME_DIR")
                for xdg_run in /run/*
                    do
                        [ "$xdg_run" != "/run/user" ] && \
                            XDG_RUN_BIND+=("--bind-try" "$xdg_run" "$xdg_run")
                done
                if [ "$UNSHARE_PIDS" == 1 ]
                    then
                        UNPIDS_BIND+=("--as-pid-1" \
                                      "--unshare-pid" \
                                      "--bind-try" "$XDG_RUNTIME_DIR/pulse" "$XDG_RUNTIME_DIR/pulse" \
                                      "--bind-try" "$XDG_RUNTIME_DIR/pipewire-0" "$XDG_RUNTIME_DIR/pipewire-0")
                        ARGS_BIND+=("dbus-launch" "--exit-with-session")
                fi
            else
                XDG_RUN_BIND=("--bind-try" "/run" "/run")
        fi
    else
        XDG_RUN_BIND=("--bind-try" "/run" "/run")
fi

if [ ! -n "$DBUS_SESSION_BUS_ADDRESS" ]
    then
        if [ -S "$XDG_RUNTIME_DIR/bus" ]
            then
                export DBUS_SESSION_BUS_ADDRESS="unix:path=$XDG_RUNTIME_DIR/bus"
        elif [ -S "/run/dbus/system_bus_socket" ]
            then
                export DBUS_SESSION_BUS_ADDRESS="unix:path=/run/dbus/system_bus_socket"
        elif [ -S "/var/run/dbus/system_bus_socket" ]
            then
                export DBUS_SESSION_BUS_ADDRESS="unix:path=/var/run/dbus/system_bus_socket"
        fi
fi

if [ -d "/tmp/.X11-unix" ] # Gamecope X11 sockets bug
    then
        if [ -L "/tmp/.X11-unix" ] # WSL
            then
                TMP_BIND+=("--tmpfs" "/tmp" \
                           "--dir" "/tmp/.X11-unix")
                for i_tmp in /tmp/*
                    do
                        [ "$i_tmp" != "/tmp/.X11-unix" ] && \
                            TMP_BIND+=("--bind-try" "$i_tmp" "$i_tmp")
                done
            else
                TMP_BIND+=("--bind-try" "/tmp" "/tmp" \
                           "--tmpfs" "/tmp/.X11-unix")
        fi
        if [ -n "$(ls -1 /tmp/.X11-unix 2>/dev/null|head -1)" ]
            then
                for x_socket in /tmp/.X11-unix/X*
                    do
                        TMP_BIND+=("--bind-try" "$x_socket" "$x_socket")
                done
        fi
    else
        TMP_BIND+=("--bind-try" "/tmp" "/tmp")
fi

if [ -d "$TMPDIR" ]
    then
        NEWTMPDIR="/tmp/.TMPDIR"
        TMPDIR_BIND+=("--dir" "$NEWTMPDIR" \
                      "--bind-try" "$TMPDIR" "$NEWTMPDIR" \
                      "--setenv" "TMPDIR" "$NEWTMPDIR")
    else
        unset TMPDIR
fi

if [ "$NO_INET" == 1 ]
    then
        NETWORK_BIND+=("--unshare-net")
        warn_msg "Network is disabled!"
    else
        NETWORK_BIND+=("--share-net" \
                       "--ro-bind-try" "/etc/hosts" "/etc/hosts" \
                       "--ro-bind-try" "/etc/resolv.conf" "/etc/resolv.conf")
fi

add_bin_pth "$HOME/.local/bin:/bin:/sbin:/usr/bin:/usr/sbin:\
/usr/lib/jvm/default/bin:/usr/local/bin:/usr/local/sbin:$SYS_PATH"
[ -n "$LD_LIBRARY_PATH" ] && \
    add_lib_pth "$LD_LIBRARY_PATH"

##############################################################################
if [ -n "$AUTORUN" ]
    then
        bwrun /usr/bin/$AUTORUN "$@"
        EXEC_STATUS="$?"
    else
        if [ ! -n "$1" ]
            then
                print_help
            else
                case $1 in
                    --runimage-help) print_help ;;
                    --runimage-bwraphelp) bwraphelp ;;
                    --runimage-pkglist) pkglist ;;
                    --runimage-binlist) binlist ;;
                    --runimage-shell) shift && bwrun /usr/bin/fish "$@" ; EXEC_STATUS="$?" ;;
                    --runimage-version) info_msg "RuntimeImage version: ${RED}$RUNIMAGE_VERSION" ;;
                    *) bwrun "$@" ; EXEC_STATUS="$?" ;;
                esac
        fi
fi
cleanup
exit $EXEC_STATUS
##############################################################################
