#!/usr/bin/env bash

DEVELOPERS="VHSgunzo"
RUNIMAGE_VERSION='0.37.5'

RED='\033[1;91m'
BLUE='\033[1;94m'
GREEN='\033[1;92m'
YELLOW='\033[1;33m'
RESETCOLOR='\033[1;00m'

RUNPID="$BASHPID"
RUNKEY="$RANDOM"
SYS_PATH="$PATH"
unset RUNMNT RUNROOTFS SQFUSE BWRAP ARIA2C NOT_TERM \
      MKSQFS NVDRVMNT BWRAP_CAP NVIDIA_DRIVER_BIND EXEC_STATUS \
      SESSION_MANAGER UNSQFS TMP_BIND SYS_HOME UNPIDS_BIND \
      NETWORK_BIND SET_HOME_DIR SET_CONF_DIR HOME_BIND BWRAP_ARGS \
      LD_CACHE_BIND ADD_LD_CACHE NEW_HOME TMPDIR_BIND EXEC_ARGS \
      SQFUSE_PIDS XDG_RUN_BIND XORG_CONF_BIND SUID_BWRAP \
      SET_RUNIMAGE_CONFIG SET_RUNIMAGE_INTERNAL_CONFIG

[[ ! -n "$LANG" || "$LANG" =~ "UTF8" ]] && \
    export LANG=en_US.UTF-8

if [[ -n "$RUNOFFSET" && -n "$ARGV0" ]]
    then
        BINDIR="$RUNDIR/static"
        export PATH="$SYS_PATH:$BINDIR"
        if [ ! -n "$RUNIMAGE" ] # KDE Neon, CachyOS, Puppy Linux bug
            then
                if [ -x "$(realpath "$ARGV0" 2>/dev/null)" ]
                    then
                        export RUNIMAGE="$(realpath "$ARGV0" 2>/dev/null)"
                elif [ -x "$(realpath "$(which "$ARGV0" 2>/dev/null)" 2>/dev/null)" ]
                    then
                        export RUNIMAGE="$(realpath "$(which "$ARGV0" 2>/dev/null)" 2>/dev/null)"
                else
                    export RUNIMAGE="$ARGV0"
                fi
        fi
        if [ -x "$(realpath -s "$ARGV0" 2>/dev/null)" ]
            then
                RUNSRC="$(realpath -s "$ARGV0" 2>/dev/null)"
        elif [ -x "$(realpath -s "$(which "$ARGV0" 2>/dev/null)" 2>/dev/null)" ]
            then
                RUNSRC="$(realpath -s "$(which "$ARGV0" 2>/dev/null)" 2>/dev/null)"
        else
            RUNSRC="$RUNIMAGE"
        fi
        export RUNIMAGEDIR="$(dirname "$RUNIMAGE" 2>/dev/null)"
        RUNIMAGENAME="$(basename "$RUNIMAGE" 2>/dev/null)"
        RUNRUNTIME_VERSION="$("$RUNIMAGE" --runtime-version|& awk '{print$2}')"
    else
        [ ! -n "$RUNDIR" ] && \
            export RUNDIR="$(dirname "$(realpath "$0" 2>/dev/null)" 2>/dev/null)"
        BINDIR="$RUNDIR/static"
        export PATH="$SYS_PATH:$BINDIR"
        export RUNIMAGEDIR="$(realpath "$RUNDIR/../" 2>/dev/null)"
        if [ -x "$(realpath -s "$0" 2>/dev/null)" ]
            then
                RUNSRC="$(realpath -s "$0" 2>/dev/null)"
        elif [ -x "$(which "$0" 2>/dev/null)" ]
            then
                RUNSRC="$(which "$0" 2>/dev/null)"
        else
            RUNSRC="$RUNDIR/Run"
        fi
        [ -x "$BINDIR/runtime-fuse2-lz4" ] && \
            RUNRUNTIME_VERSION="$("$BINDIR/runtime-fuse2-lz4" --runtime-version|& awk '{print$2}')"
fi

export RUNROOTFS="$RUNDIR/rootfs"
export RUNCACHEDIR="$RUNIMAGEDIR/cache"
RUNSRCNAME="$(basename "$RUNSRC" 2>/dev/null)"
RUNROOTFS_VERSION="$(cat "$RUNROOTFS/.version" 2>/dev/null)"
RUNSTATIC_VERSION="$(cat "$BINDIR/.version" 2>/dev/null)"

[ ! -n "$(tty|grep -v 'not a'|grep -Eo 'tty|pts')" ] && \
    NOT_TERM=1

error_msg() {
    echo -e "${RED}[ ERROR ][$(date +"%Y.%m.%d %T")]: $1 $RESETCOLOR"
    if [ "$NOT_TERM" == 1 ]
        then
            notify-send -a 'RunImage Error' "$1" 2>/dev/null &
    fi
}

info_msg() {
    if [ "$QUIET_MODE" != 1 ]
        then
            echo -e "${GREEN}[ INFO ][$(date +"%Y.%m.%d %T")]: $1 $RESETCOLOR"
            if [[ "$NOT_TERM" == 1 && "$NO_NOTIFY" != 1 ]]
                then
                    notify-send -a 'RunImage Info' "$1" 2>/dev/null &
            fi
    fi
}

warn_msg() {
    if [ "$QUIET_MODE" != 1 ]
        then
            echo -e "${YELLOW}[ WARNING ][$(date +"%Y.%m.%d %T")]: $1 $RESETCOLOR"
            if [[ "$NOT_TERM" == 1 && "$NO_NOTIFY" != 1 ]]
                then
                    notify-send -a 'RunImage Warning' "$1" 2>/dev/null &
            fi
    fi
}

console_info_notify() {
    if [[ "$NOT_TERM" == 1 && "$NO_NOTIFY" != 1 ]]
        then
            notify-send -a "RunImage Info" "See the information in the console!" &
        else
            return 1
    fi
}

mount_exist() {
    time_out=1000 # =~ 3 sec
    wait_time=0
    while true
        do
            if [ "$wait_time" -le "$time_out" ]
                then
                    if [[ -d "/proc/$1" && -n "$(ls -A "$2" 2>/dev/null)" ]]
                        then
                            return 0
                        else
                            wait_time="$(( $wait_time + 1 ))"
                            sleep 0.0001
                    fi
                else
                    return 1
            fi
    done
}

is_sys_exe() {
    if [[ -x "$(which -a "$1" 2>/dev/null|grep -v "$BINDIR"|head -1)" ]]
        then
            return 0
        else
            return 1
    fi
}

which_sys_exe() { which -a "$1" 2>/dev/null|grep -v "$BINDIR"|head -1 ; }

try_dl() { "$ARIA2C" -x 13 -s 13 --allow-overwrite -d "$1" "$2" ; return $? ; }

get_nvidia_driver_image() {
    (if [[ -n "$1" || -n "$nvidia_version" ]]
        then
            [ ! -n "$nvidia_version" ] && \
                nvidia_version="$1"
            [[ -d "$2" && ! -n "$nvidia_drivers_dir" ]] && \
                nvidia_drivers_dir="$2"
            [[ ! -d "$2" && ! -n "$nvidia_drivers_dir" ]] && \
                nvidia_drivers_dir="."
            [ ! -n "$nvidia_driver_image" ] && \
                nvidia_driver_image="$nvidia_version.nv.drv"
            try_mkdir "$nvidia_drivers_dir"
            info_msg "Downloading Nvidia ${nvidia_version} driver, please wait..."
            nvidia_driver_run="NVIDIA-Linux-x86_64-${nvidia_version}.run"
            driver_url_list=("https://github.com/VHSgunzo/runimage-nvidia-drivers/releases/download/v${nvidia_version}/$nvidia_driver_image" \
                             "https://us.download.nvidia.com/XFree86/Linux-x86_64/${nvidia_version}/$nvidia_driver_run")
            if try_dl "$nvidia_drivers_dir" "${driver_url_list[0]}"
                then
                    return 0
            elif try_dl "$nvidia_drivers_dir" "${driver_url_list[1]}"
                then
                    trash_libs="libEGL.so.1.1.0 libGLdispatch.so.0 \
                        libGLESv1_CM.so.1.2.0 libGLESv2.so.2.1.0 libGL.so.1.7.0 \
                        libGLX.so.0 libOpenCL.so.1.0.0 libOpenGL.so.0 \
                        libnvidia-opencl* libnvidia-compiler* libcudadebugger*"
                    chmod u+x "$nvidia_drivers_dir/$nvidia_driver_run"
                    info_msg "Unpacking $nvidia_driver_run..."
                    (cd "$nvidia_drivers_dir" && \
                        "./$nvidia_driver_run" -x &>/dev/null
                        rm -f "$nvidia_driver_run"
                        mv -f "NVIDIA-Linux-x86_64-${nvidia_version}" "$nvidia_version")
                    info_msg "Creating a driver directory structure..."
                    (cd "$nvidia_drivers_dir/$nvidia_version" && \
                        rm -rf html kernel* libglvnd_install_checker 32/libglvnd_install_checker \
                            supported-gpus systemd *.gz *.bz2 *.txt *Changelog LICENSE \
                            .manifest *.desktop *.png 2>/dev/null
                        try_mkdir profiles && mv *application-profiles* profiles
                        try_mkdir wine && mv *nvngx.dll wine
                        try_mkdir json && mv *.json json
                        try_mkdir conf && mv *.conf *.icd conf
                        for lib in $trash_libs ; do rm $lib 32/$lib 2>/dev/null ; done
                        try_mkdir bin && mv *.sh mkprecompiled nvidia-cuda-mps-control nvidia-cuda-mps-server \
                            nvidia-debugdump nvidia-installer nvidia-modprobe nvidia-ngx-updater \
                            nvidia-persistenced nvidia-powerd nvidia-settings nvidia-smi nvidia-xconfig bin
                        try_mkdir 64 && mv *.so* 64)
                    info_msg "Creating a squashfs driver image..."
                    info_msg "$nvidia_drivers_dir/$nvidia_driver_image"
                    if "$MKSQFS" "$nvidia_drivers_dir/$nvidia_version" "$nvidia_drivers_dir/$nvidia_driver_image" \
                        -root-owned -no-xattrs -noappend -b 256K -comp lz4 -Xhc -quiet
                        then
                            info_msg "Deleting the source directory of the driver..."
                            rm -rf "$nvidia_drivers_dir/$nvidia_version"
                            return 0
                        else
                            return 1
                    fi
                else
                    error_msg "Failed to download Nvidia driver!"
                    return 1
            fi
        else
            error_msg "You must specify the nvidia driver version!"
            return 1
    fi)
}

mount_nvidia_driver_image() {
    if [[ -n "$1" && -n "$(echo "$1"|grep -o "\.nv\.drv$")" ]]
        then
            [ ! -n "$nvidia_version" ] && \
                nvidia_version="$(echo "$1"|sed 's|.nv.drv||g')"
            [ ! -n "$NVDRVMNT" ] && \
                NVDRVMNT="/tmp/.mount_nv${nvidia_version}drv.$RUNKEY"
            info_msg "Mounting the nvidia driver image: $(basename "$1")"
            try_mkdir "$NVDRVMNT"
            "$SQFUSE" -f "$1" "$NVDRVMNT" -o ro &
            SQFUSE_PID="$!"
            export SQFUSE_PIDS="$SQFUSE_PID $SQFUSE_PIDS"
            if mount_exist "$SQFUSE_PID" "$NVDRVMNT"
                then
                    nvidia_driver_dir="$NVDRVMNT"
                else
                    error_msg "Failed to mount the nvidia driver image!"
            fi
        else
            error_msg "You must specify the nvidia driver image!"
            return 1
    fi
}

check_nvidia_driver() {
    unset NVIDIA_DRIVER_BIND
    print_nv_drv_dir() { info_msg "Found Nvidia driver directory: $(basename "$nvidia_driver_dir")" ; }
    if lsmod|grep nvidia &>/dev/null || nvidia-smi &>/dev/null
        then
            unset nvidia_driver_dir
            nvidia_drivers_dir="$RUNIMAGEDIR/nvidia-drivers"
            if modinfo nvidia &>/dev/null
                then
                    nvidia_version="$(modinfo -F version nvidia 2>/dev/null)"
            elif nvidia-smi &>/dev/null
                then
                    nvidia_version="$(nvidia-smi --query-gpu=driver_version --format=csv,noheader|head -1)"
            else
                if [ -d /usr/lib/x86_64-linux-gnu ]
                    then
                        nvidia_version="$(basename /usr/lib/x86_64-linux-gnu/libGLX_nvidia.so.*.*|tail -c +18)"
                    else
                        nvidia_version="$(basename /usr/lib/libGLX_nvidia.so.*.*|tail -c +18)"
                fi
            fi
            if [ -n "$nvidia_version" ]
                then
                    nvidia_version_inside="$(basename "$RUNROOTFS/usr/lib/libGLX_nvidia.so".*.*|tail -c +18)"
                    if [ -n "$nvidia_version_inside" ]
                        then
                            nvidia_driver_image="$nvidia_version.nv.drv"
                            NVDRVMNT="/tmp/.mount_nv${nvidia_version}drv.$RUNKEY"
                            [ "${nvidia_version}" != "${nvidia_version_inside}" ] && \
                            [ "$nvidia_version_inside" != "000.00.00" ] && \
                                warn_msg "Nvidia driver version mismatch detected, trying to fix it"
                            if [ ! -f "$nvidia_drivers_dir/$nvidia_version/64/nvidia_drv.so" ] && \
                               [ ! -f "$RUNIMAGEDIR/$nvidia_driver_image" ] && \
                               [ ! -f "$nvidia_drivers_dir/$nvidia_driver_image" ] && \
                               [ ! -f "$NVDRVMNT/64/nvidia_drv.so" ] && \
                               [ ! -f "$RUNDIR/nvidia-drivers/$nvidia_version/64/nvidia_drv.so" ] && \
                               [ ! -f "$RUNDIR/nvidia-drivers/$nvidia_driver_image" ] && \
                               [ "${nvidia_version}" != "${nvidia_version_inside}" ]
                                then
                                    if get_nvidia_driver_image
                                        then
                                            mount_nvidia_driver_image "$nvidia_drivers_dir/$nvidia_driver_image"
                                        else
                                            nvidia_driver_dir="$nvidia_drivers_dir/$nvidia_version"
                                    fi
                                else
                                    if [ -f "$NVDRVMNT/64/nvidia_drv.so" ]
                                        then
                                            nvidia_driver_dir="$NVDRVMNT"
                                            print_nv_drv_dir
                                    elif [ -f "$nvidia_drivers_dir/$nvidia_version/64/nvidia_drv.so" ]
                                        then
                                            nvidia_driver_dir="$nvidia_drivers_dir/$nvidia_version"
                                            print_nv_drv_dir
                                    elif [ -f "$RUNIMAGEDIR/$nvidia_driver_image" ]
                                        then
                                            mount_nvidia_driver_image "$RUNIMAGEDIR/$nvidia_driver_image"
                                    elif [ -f "$nvidia_drivers_dir/$nvidia_driver_image" ]
                                        then
                                            mount_nvidia_driver_image "$nvidia_drivers_dir/$nvidia_driver_image"
                                    elif [ -f "$RUNDIR/nvidia-drivers/$nvidia_version/64/nvidia_drv.so" ]
                                        then
                                            nvidia_driver_dir="$RUNDIR/nvidia-drivers/$nvidia_version"
                                            print_nv_drv_dir
                                    elif [ -f "$RUNDIR/nvidia-drivers/$nvidia_driver_image" ]
                                        then
                                            mount_nvidia_driver_image "$RUNDIR/nvidia-drivers/$nvidia_driver_image"
                                    fi
                            fi
                        else
                            error_msg "No Nvidia driver found inside the RunImage!"
                            return 1
                    fi
                    if [ -f "$nvidia_driver_dir/64/nvidia_drv.so" ]
                        then
                            nvidia_libs_list="libcuda.so libEGL_nvidia.so libGLESv1_CM_nvidia.so \
                                libGLESv2_nvidia.so libGLX_nvidia.so libnvcuvid.so libnvidia-allocator.so \
                                libnvidia-cfg.so libnvidia-eglcore.so libnvidia-encode.so libnvidia-fbc.so \
                                libnvidia-glcore.so libnvidia-glsi.so libnvidia-glvkspirv.so libnvidia-ml.so \
                                libnvidia-ngx.so libnvidia-opticalflow.so libnvidia-ptxjitcompiler.so \
                                libnvidia-rtcore.so libnvidia-tls.so libnvidia-vulkan-producer.so libnvoptix.so"
                            for lib in ${nvidia_libs_list}
                                do
                                    if [ -f "$RUNROOTFS/usr/lib/${lib}.${nvidia_version_inside}" ]
                                        then
                                            NVIDIA_DRIVER_BIND+=("--ro-bind-try" \
                                                "$nvidia_driver_dir/64/${lib}.${nvidia_version}" \
                                                "/usr/lib/${lib}.${nvidia_version_inside}")
                                    fi
                                    if [ -f "$RUNROOTFS/usr/lib32/${lib}.${nvidia_version_inside}" ]
                                        then
                                            NVIDIA_DRIVER_BIND+=("--ro-bind-try" \
                                                "$nvidia_driver_dir/32/${lib}.${nvidia_version}" \
                                                "/usr/lib32/${lib}.${nvidia_version_inside}")
                                    fi
                            done
                            if [ -f "$RUNROOTFS/usr/lib/firmware/nvidia/${nvidia_version_inside}/gsp.bin" ]
                                then
                                    NVIDIA_DRIVER_BIND+=("--ro-bind-try" \
                                        "$nvidia_driver_dir/firmware/gsp.bin" \
                                        "/usr/lib/firmware/nvidia/${nvidia_version_inside}/gsp.bin")
                            fi
                            if [ -f "$RUNROOTFS/usr/lib/libnvidia-egl-gbm.so.1.1.0" ]
                                then
                                    NVIDIA_DRIVER_BIND+=("--ro-bind-try" \
                                        "$nvidia_driver_dir/64/libnvidia-egl-gbm.so.1.1.0" \
                                        "/usr/lib/libnvidia-egl-gbm.so.1.1.0")
                            fi
                            if [ -f "$RUNROOTFS/usr/lib/nvidia/xorg/libglxserver_nvidia.so.${nvidia_version_inside}" ]
                                then
                                    NVIDIA_DRIVER_BIND+=("--ro-bind-try" \
                                        "$nvidia_driver_dir/64/libglxserver_nvidia.so.${nvidia_version}" \
                                        "/usr/lib/nvidia/xorg/libglxserver_nvidia.so.${nvidia_version_inside}")
                            fi
                            if [ -f "$RUNROOTFS/usr/lib/vdpau/libvdpau_nvidia.so.${nvidia_version_inside}" ]
                                then
                                    NVIDIA_DRIVER_BIND+=("--ro-bind-try" \
                                        "$nvidia_driver_dir/64/libvdpau_nvidia.so.${nvidia_version}" \
                                        "/usr/lib/vdpau/libvdpau_nvidia.so.${nvidia_version_inside}")
                            fi
                            if [ -f "$RUNROOTFS/usr/lib32/vdpau/libvdpau_nvidia.so.${nvidia_version_inside}" ]
                                then
                                    NVIDIA_DRIVER_BIND+=("--ro-bind-try" \
                                        "$nvidia_driver_dir/32/libvdpau_nvidia.so.${nvidia_version}" \
                                        "/usr/lib32/vdpau/libvdpau_nvidia.so.${nvidia_version_inside}")
                            fi
                            if [ -f "$RUNROOTFS/usr/lib/xorg/modules/drivers/nvidia_drv.so" ]
                                then
                                    NVIDIA_DRIVER_BIND+=("--ro-bind-try" \
                                        "$nvidia_driver_dir/64/nvidia_drv.so" \
                                        "/usr/lib/xorg/modules/drivers/nvidia_drv.so")
                            fi
                            if [ -f "$RUNROOTFS/usr/share/egl/egl_external_platform.d/15_nvidia_gbm.json" ]
                                then
                                    NVIDIA_DRIVER_BIND+=("--ro-bind-try" \
                                        "$nvidia_driver_dir/json/15_nvidia_gbm.json" \
                                        "/usr/share/egl/egl_external_platform.d/15_nvidia_gbm.json")
                            fi
                            if [ -f "$RUNROOTFS/usr/share/glvnd/egl_vendor.d/10_nvidia.json" ]
                                then
                                    NVIDIA_DRIVER_BIND+=("--ro-bind-try" \
                                        "$nvidia_driver_dir/json/10_nvidia.json" \
                                        "/usr/share/glvnd/egl_vendor.d/10_nvidia.json")
                            fi
                            if [ -f "$RUNROOTFS/usr/share/vulkan/icd.d/nvidia_icd.json" ]
                                then
                                    NVIDIA_DRIVER_BIND+=("--ro-bind-try" \
                                        "$nvidia_driver_dir/json/nvidia_icd.json" \
                                        "/usr/share/vulkan/icd.d/nvidia_icd.json")
                            fi
                            if [ -f "$RUNROOTFS/usr/share/vulkan/implicit_layer.d/nvidia_layers.json" ]
                                then
                                    NVIDIA_DRIVER_BIND+=("--ro-bind-try" \
                                        "$nvidia_driver_dir/json/nvidia_layers.json" \
                                        "/usr/share/vulkan/implicit_layer.d/nvidia_layers.json")
                            fi
                            if [ -f "$RUNROOTFS/usr/share/dbus-1/system.d/nvidia-dbus.conf" ]
                                then
                                    NVIDIA_DRIVER_BIND+=("--ro-bind-try" \
                                        "$nvidia_driver_dir/conf/nvidia-dbus.conf" \
                                        "/usr/share/dbus-1/system.d/nvidia-dbus.conf")
                            fi
                            if [ -d "$RUNROOTFS/usr/share/nvidia" ]
                                then
                                    NVIDIA_DRIVER_BIND+=("--ro-bind-try" \
                                        "$nvidia_driver_dir/profiles" \
                                        "/usr/share/nvidia")
                            fi
                            if [ -d "$RUNROOTFS/usr/lib/nvidia/wine" ]
                                then
                                    NVIDIA_DRIVER_BIND+=("--ro-bind-try" \
                                        "$nvidia_driver_dir/wine" \
                                        "/usr/lib/nvidia/wine")
                            fi
                            NVIDIA_DRIVER_BIND+=("--ro-bind-try" "$nvidia_driver_dir/bin" "/usr/bin/nvidia" \
                                "--ro-bind-try" "$nvidia_driver_dir/64" "/usr/lib/nvidia/64" \
                                "--ro-bind-try" "$nvidia_driver_dir/32" "/usr/lib/nvidia/32")
                            add_bin_pth '/usr/bin/nvidia'
                            add_lib_pth '/usr/lib/nvidia/64:/usr/lib/nvidia/32'
                            if [ "$(cat "$RUNCACHEDIR/ld.so.version" 2>/dev/null)" != "$RUNROOTFS_VERSION-$nvidia_version" ]
                                then
                                    info_msg "Updating the nvidia library cache..."
                                    if bwrun /usr/bin/ldconfig -C "/tmp/ld.so.cache" 2>/dev/null
                                        then
                                            try_mkdir "$RUNCACHEDIR"
                                            if mv -f "/tmp/ld.so.cache" \
                                                "$RUNCACHEDIR/ld.so.cache" 2>/dev/null
                                                then
                                                    echo "$RUNROOTFS_VERSION-$nvidia_version" > \
                                                         "$RUNCACHEDIR/ld.so.version"
                                                    ADD_LD_CACHE=1
                                                else
                                                    error_msg "Failed to merge nvidia library cache!"
                                            fi
                                        else
                                            error_msg "Failed to update nvidia library cache!"
                                    fi
                                else
                                    ADD_LD_CACHE=1
                            fi
                    fi
            fi
    fi
}

add_lib_pth() {
    if [ -n "$LIB_PATH" ]
        then
            if [ ! -n "$(echo "$LIB_PATH"|grep -ow "$1" 2>/dev/null)" ]
                then
                    LIB_PATH="${1}:${LIB_PATH}"
            fi
        else
            LIB_PATH="${1}"
    fi
}

add_bin_pth() {
    if [ -n "$BIN_PATH" ]
        then
            if [ ! -n "$(echo "$BIN_PATH"|grep -ow "$1" 2>/dev/null)" ]
                then
                    BIN_PATH="${1}:${BIN_PATH}"
            fi
        else
            BIN_PATH="${1}"
    fi
}

try_unmount() {
    if [ -d "$1" ]
        then
            unset DORM
            if fusermount -uz "$1" 2>/dev/null
                then DORM=1
            elif umount -l "$1" 2>/dev/null
                then DORM=1
            elif kill $SQFUSE_PIDS 2>/dev/null
                then DORM=1
            else
                error_msg "Failed to unmount: '$1'"
                return 1
            fi
            [ "$DORM" == 1 ] && \
                rm -rf "$1" 2>/dev/null
    fi
}

try_mkdir() {
    if [ ! -d "$1" ]
        then
            if ! mkdir -p "$1"
                then
                    error_msg "Failed to create directory: '$1'"
                    FORCE_CLEANUP=1 cleanup
                    exit 1
            fi
    fi
}

cleanup() {
    if [[ "$NO_CLEANUP" != 1 || "$FORCE_CLEANUP" == 1 ]]
        then
            if [ -n "$SQFUSE_PIDS" ]
                then
                    try_unmount "$RUNMNT"
                    try_unmount "$NVDRVMNT"
                    if [ "$FORCE_CLEANUP" == 1 ]
                        then
                            warn_msg "Forced cleanup is enabled!"
                            ALLPIDS="$(lsof -n "$RUNDIR" 2>/dev/null|sed 1d|\
                                        grep -v "$RUNPID"|awk '{print$2}'|sort -u)"
                            [ -n "$ALLPIDS" ] && \
                                kill -9 $ALLPIDS 2>/dev/null
                        else
                            kill $SQFUSE_PIDS 2>/dev/null
                    fi
            fi
        else
            warn_msg "Cleanup is disabled!"
    fi
}

bwrun() {
    "$BWRAP" --bind-try "$RUNROOTFS" / \
        --proc /proc \
        --tmpfs /var/log \
        --die-with-parent \
        --bind-try /sys /sys \
        --bind-try /mnt /mnt \
        --bind-try /srv /srv \
        --bind-try /boot /boot \
        --dev-bind-try /dev /dev \
        --bind-try /media /media \
        --bind-try /var/tmp /var/tmp \
        --bind-try /var/mnt /var/mnt \
        --bind-try /var/opt /var/opt \
        --bind-try /var/home /var/home \
        --bind-try /var/empty /var/empty \
        --bind-try /var/spool /var/spool \
        --bind-try /var/local /var/local \
        --bind-try /var/games /var/games \
        --ro-bind-try /etc/group /etc/group \
        --bind-try /lib/modules /lib/modules \
        --ro-bind-try /etc/passwd /etc/passwd \
        --bind-try /var/roothome /var/roothome \
        --ro-bind-try /etc/hostname /etc/hostname \
        --ro-bind-try /etc/localtime /etc/localtime \
        --ro-bind-try /etc/machine-id /etc/machine-id \
        --ro-bind-try /etc/nsswitch.conf /etc/nsswitch.conf \
        "${NVIDIA_DRIVER_BIND[@]}" "${TMP_BIND[@]}" \
        "${NETWORK_BIND[@]}" "${XDG_RUN_BIND[@]}" \
        "${LD_CACHE_BIND[@]}" "${TMPDIR_BIND[@]}" \
        "${UNPIDS_BIND[@]}" "${HOME_BIND[@]}" \
        "${XORG_CONF_BIND[@]}" "${BWRAP_CAP[@]}" \
        --setenv PATH "$BIN_PATH" \
        --setenv LD_LIBRARY_PATH "$LIB_PATH" \
        --setenv NO_AT_BRIDGE '1' \
        --setenv GDK_BACKEND 'x11' \
        --setenv SHELL '/usr/bin/fish' \
        --setenv DESKTOP_SESSION 'xfce' \
        --setenv ZDOTDIR '/etc/zsh/zshrc' \
        --setenv GTK_THEME 'Adwaita:dark' \
        --setenv XDG_CURRENT_DESKTOP 'XFCE' \
        --setenv QT_QPA_PLATFORMTHEME 'qt5ct' \
        --setenv GTK2_RC_FILES '/usr/share/gtk-2.0/gtkrc' \
        --setenv XDG_CONFIG_DIRS "/etc/xdg:$XDG_CONFIG_DIRS" \
        --setenv XDG_DATA_DIRS "/usr/local/share:/usr/share:$XDG_DATA_DIRS" \
        "${BWRAP_ARGS[@]}" "${EXEC_ARGS[@]}" \
        "$@"
    return $?
}

pkg_list() { NO_NVIDIA_CHECK=1 QUIET_MODE=1 bwrun /usr/bin/pacman -Q 2>/dev/null ; }

bin_list() { NO_NVIDIA_CHECK=1 QUIET_MODE=1 bwrun /usr/bin/find /usr/bin/ \
            -executable -type f -maxdepth 1 2>/dev/null|sed 's|/usr/bin/||g' ; }

bwrap_help() { NO_NVIDIA_CHECK=1 QUIET_MODE=1 bwrun --help ; }

print_version() {
    info_msg "RunImage version: ${RED}$RUNIMAGE_VERSION"
    info_msg "RootFS version: ${RED}$RUNROOTFS_VERSION"
    info_msg "Static version: ${RED}$RUNSTATIC_VERSION"
    [ -n "$RUNRUNTIME_VERSION" ] && \
        info_msg "RunImage runtime version: ${RED}$RUNRUNTIME_VERSION"
}

print_help() {
if ! console_info_notify
    then
    echo -e "
${GREEN}RunImage ${RED}v${RUNIMAGE_VERSION} ${GREEN}by $DEVELOPERS
    ${RED}Usage:
        $RED┌──[$GREEN$RUNUSER$YELLOW@$BLUE$(uname -a|awk '{print$2}')$RED]─[$GREEN$PWD$RED]
        $RED└──╼ \$$GREEN $([ -n "$RUNIMAGE" ] && echo "$RUNIMAGE"||echo "$0") {executable} $YELLOW{arguments}

        ${BLUE}--runimage-help$GREEN                      Show this usage info
        ${BLUE}--runimage-bwraphelp$GREEN                 Show Bubblewrap usage info
        ${BLUE}--runimage-version$GREEN                   Show the runimage version
        ${BLUE}--runimage-pkglist$GREEN                   Show packages installed in runimage
        ${BLUE}--runimage-binlist$GREEN                   Show /usr/bin in runimage
        ${BLUE}--runimage-shell$YELLOW {args}$GREEN              Run the runimage shell or execute a command in runimage shell
        ${BLUE}--runimage-desktop$GREEN                   Launch the runimage desktop

    ${RED}Only for not extracted (RunImage runtime options):
        ${BLUE}--runtime-extract$YELLOW {pattern}$GREEN          Extract content from embedded filesystem image
        ${BLUE}--runtime-extract-and-run $YELLOW{args}$GREEN     Run the runimage afer extraction without using FUSE
        ${BLUE}--runtime-help$GREEN                       Show runimage runtime help (Shown in this help)
        ${BLUE}--runtime-mount$GREEN                      Mount embedded filesystem image and print
        ${BLUE}--runtime-offset$GREEN                     Print byte offset to start of embedded
        ${BLUE}--runtime-portable-home$GREEN              Create a portable home folder to use as ${YELLOW}\$HOME$GREEN
        ${BLUE}--runtime-portable-config$GREEN            Create a portable config folder to use as ${YELLOW}\$XDG_CONFIG_HOME$GREEN
        ${BLUE}--runtime-version$GREEN                    Print version of runimage runtime

    ${RED}Environment variables:
        ${YELLOW}NO_INET$GREEN=1                            Disables network access
        ${YELLOW}TMP_HOME$GREEN=1                           Creates tmpfs /home/\$USER and /root in RAM and uses it as ${YELLOW}\$HOME
        ${YELLOW}TMP_HOME_DL$GREEN=1                        As above, but with binding ${YELLOW}\$HOME${GREEN}/Downloads directory
        ${YELLOW}PORTABLE_HOME$GREEN=1                      Creates a portable home folder and uses it as ${YELLOW}\$HOME
        ${YELLOW}PORTABLE_CONFIG$GREEN=1                    Creates a portable config folder and uses it as ${YELLOW}\$XDG_CONFIG_HOME
        ${YELLOW}NO_CLEANUP$GREEN=1                         Disables unmounting and cleanup mountpoints
        ${YELLOW}FORCE_CLEANUP$GREEN=1                      Kills all runimage background processes when exiting
        ${YELLOW}NO_NVIDIA_CHECK$GREEN=1                    Disables checking the nvidia driver version
        ${YELLOW}NO_CAP$GREEN=1                             Disables Bubblewrap capabilities
        ${YELLOW}AUTORUN$GREEN=\"{executable} {args}\"        Run the runimage with autorun options for /usr/bin executables
        ${YELLOW}ALLOW_ROOT$GREEN=1                         Allows to run runimage under root user
        ${YELLOW}QUIET_MODE$GREEN=1                         Disables all non-error runimage messages
        ${YELLOW}NO_NOTIFY$GREEN=1                          Disables all notification
        ${YELLOW}UNSHARE_PIDS$GREEN=1                       Hides all system processes inside the runimage
        ${YELLOW}RUNTIME_EXTRACT_AND_RUN$GREEN=1            Run the runimage afer extraction without using FUSE
        ${YELLOW}TMPDIR$GREEN=\"/path/TMPDIR\"                Used for extract and run options
        ${YELLOW}RUNIMAGE_CONFIG$GREEN=\"/path/{config_name}.rcfg\"    runimage сonfiguration file (0 to disable)
        ${YELLOW}XORG_CONF$GREEN=\"/path/xorg.conf\"          Binds xorg.conf to /etc/X11/xorg.conf inside runimage
                                             by default, /etc/X11/xorg.conf bind from the system (0 to disable)
        ${YELLOW}XEPHYR_SIZE$GREEN=\"HEIGHTxWIDTH\"           Sets the runimage desktop resolution (Default: 1600x900)
        ${YELLOW}XEPHYR_DISPLAY$GREEN=\":9999\"               Sets the runimage desktop \$DISPLAY (Default: :1337)
        ${YELLOW}XEPHYR_FULLSCREEN$GREEN=1                  Starts the runimage desktop in full screen mode
        ${YELLOW}UNSHARE_CLIPBOARD$GREEN=1                  Disables clipboard synchronization for the runimage desktop

        ${YELLOW}SYS_BWRAP$GREEN=1                          Using system ${BLUE}bwrap
        ${YELLOW}SYS_SQFUSE$GREEN=1                         Using system ${BLUE}squashfuse
        ${YELLOW}SYS_ARIA2C$GREEN=1                         Using system ${BLUE}aria2c
        ${YELLOW}SYS_UNSQFS$GREEN=1                         Using system ${BLUE}unsquashfs
        ${YELLOW}SYS_MKSQFS$GREEN=1                         Using system ${BLUE}mksquashfs
        ${YELLOW}SYS_TOOLS$GREEN=1                          Using all these binaries from the system
                                             If they are not found in the system - auto return to the built-in

    ${RED}Additional information:${GREEN}
        You can create a symlink/hardlink to the runimage or rename runimage and give it the name
            of some executable file from /usr/bin inside the runimage, this will allow you to run
            the runimage in autorun mode for this executable file.
        The same principle applies to the ${YELLOW}AUTORUN$GREEN variable:
            $RED┌─[$GREEN$RUNUSER$YELLOW@$BLUE$(uname -a|awk '{print$2}')$RED]─[$GREEN$PWD$RED]
            $RED└──╼ \$ ${GREEN}export ${YELLOW}AUTORUN=\"ls -la\"
            $RED└──╼ \$ ${GREEN}runimage ${YELLOW}{args}${GREEN}
            Here runimage will become something like an alias for 'ls' inside the runimage
            with the '-la' argument.
        This will also work in extracted form for the Run script.

        When using the ${YELLOW}PORTABLE_HOME$GREEN and ${YELLOW}PORTABLE_CONFIG$GREEN variables, runimage will create or
            search for these directories next to itself. The same behavior will occur when
            adding a runimage or Run script or renamed or symlink/hardlink to them in the PATH
            it can be used both extracted and compressed:
                ${YELLOW}'$RUNIMAGEDIR/Run.home'
                ${YELLOW}'$RUNIMAGEDIR/Run.config'$GREEN
            if a symlink/hardlink to the runimage is used:
                ${YELLOW}'$RUNIMAGEDIR/{symlink/hardlink_name}.home'
                ${YELLOW}'$RUNIMAGEDIR/{symlink/hardlink_name}.config'$GREEN
            or with the runimage/Run name:
                ${YELLOW}'$RUNIMAGEDIR/{runimage/Run_name}.home'
                ${YELLOW}'$RUNIMAGEDIR/{runimage/Run_name}.config'$GREEN
            It can also be with the name of the executable file from ${YELLOW}\$AUTORUN$GREEN environment variables

        RunImage uses fakeroot and fakechroot, which allows you to use root commands, including in
            unpacked form, to update the rootfs or install/remove packages. Sudo and pkexec have
            also been replaced with fake ones.

        ${RED}RunImage configuration file:${GREEN}
            Special BASH-syntax file with the .rcfg extension, which describes additional
                instructions and environment variables for running runimage.
            Сonfiguration file can be located next to the runimage:
                ${YELLOW}'$RUNIMAGEDIR/{runimage/Run_name}.rcfg'$GREEN
            if a symlink/hardlink to the runimage is used:
                ${YELLOW}'$RUNIMAGEDIR/{symlink/hardlink_name}.rcfg'$GREEN
            or in ${YELLOW}\$RUNIMAGEDIR$GREEN/config directory:
                ${YELLOW}'$RUNIMAGEDIR/config/{runimage/Run_name}.rcfg'$GREEN
                ${YELLOW}'$RUNIMAGEDIR/config/{symlink/hardlink_name}.rcfg'$GREEN
            It can also be with the name of the executable file from ${YELLOW}\$AUTORUN$GREEN environment variables
            In \$RUNDIR/config there are default configs inside RunImage, they are run in priority,
                then external configs are run if they are found.

        ${RED}RunImage desktop:${GREEN}
            Ability to run RunImage in desktop mode. By default, XFCE is used.
            If the launch is carried out from an already running desktop, then Xephyr will start
                in windowed mode (see XEPHYR_* environment variables)
            It is also possible to run on TTY with Xorg (see XORG_CONF environment variables)
                To do this, just log in to TTY and run RunImage desktop.
            ${RED}Important!${GREEN} The launch on the TTY should be carried out only under the user under whom the
                login to the TTY was carried out.

        ${RED}For Nvidia users with a proprietary driver:${GREEN}
            If the nvidia driver version does not match inside runimage and in the host, runimage
                will make an image with the nvidia driver of the required version (requires internet)
                or will download a ready-made image from the github repository.
            You can download a ready-made driver image from the releases or build driver image manually:
                ${BLUE}https://github.com/VHSgunzo/runimage-nvidia-drivers${GREEN}
            Inside runimage, a fake version of the nvidia driver is installed by default to reduce
                the size, so for nvidia users, an image of the nvidia driver will be automatically
                created and further used as an additional module to runimage.
            But you can also install the usual nvidia driver of your version in runimage.
            Checking the nvidia driver version can be disabled using ${YELLOW}NO_NVIDIA_CHECK$GREEN variable.
                the nvidia driver image can be located next to the runimage:
                    ${YELLOW}'$RUNIMAGEDIR/{nvidia_version}.nv.drv'$GREEN
                or in ${YELLOW}\$RUNIMAGEDIR$GREEN/nvidia-drivers (Default):
                    ${YELLOW}'$RUNIMAGEDIR/nvidia-drivers/{nvidia_version}.nv.drv'$GREEN
                or the driver can be extracted as the directory
                    ${YELLOW}'$RUNIMAGEDIR/nvidia-drivers/{nvidia_version}'$GREEN
                also, the driver can be inside the container in a packed or unpacked form:
                    ${YELLOW}'\$RUNDIR/nvidia-drivers/{nvidia_version}.nv.drv'$GREEN   -  image
                    ${YELLOW}'\$RUNDIR/nvidia-drivers/{nvidia_version}'$GREEN          -  directory

    ${RED}Recommendations:${GREEN}
        If the kernel does not support user namespaces, you need to install
            SUID Bubblewrap into the system, or install a kernel with user namespaces support.
            If SUID Bubblewrap is found in the system, it will be used automatically.
        If you use SUID Bubblewrap, then you will encounter some limitations, such as the inability to use
            FUSE inside the container, without running it under the root user, because the capabilities are
            disabled, and so on. So it would be better for you to install kernel with
            user namespaces support.
        I recommend installing the XanMod kernel (${BLUE}https://xanmod.org${GREEN}), because I noticed that the speed
            of runimage in compressed form on this kernel is much higher due to more correct caching settings
            and special patches.
    $RESETCOLOR" >&2
fi
}

if [[ "$EUID" == 0 && "$ALLOW_ROOT" != 1 ]]
    then
        error_msg "root user is not allowed!"
        if ! console_info_notify
            then
                echo -e "${RED}\t\t\tDo not run RunImage as root!"
                echo -e "If you really need to run it as root set the ${YELLOW}ALLOW_ROOT${GREEN}=1 ${RED}environment variable.$RESETCOLOR"
                exit 1
        fi
fi

if [[ "$RUNSRCNAME" != "Run"* && \
      "$RUNSRCNAME" != "runimage"* ]]
   then
        AUTORUN="$RUNSRCNAME"
fi

if [ ! -n "$AUTORUN" ]
    then
        case $1 in
            --*) : ;;
            *)
                [[ -x "$RUNROOTFS/usr/bin/$1" || -x "$1" ]] && \
                    RUNSRCNAME="$(basename "$1")"
            ;;
        esac
fi

if [ "$RUNIMAGE_CONFIG" != 0 ]
    then
        if [ -f "$RUNDIR/config/$RUNSRCNAME.rcfg" ]
            then
                RUNIMAGE_INTERNAL_CONFIG="$RUNDIR/config/$RUNSRCNAME.rcfg"
                SET_RUNIMAGE_INTERNAL_CONFIG=1
        elif [ -f "$RUNDIR/config/Run.rcfg" ]
            then
                RUNIMAGE_INTERNAL_CONFIG="$RUNDIR/config/Run.rcfg"
                SET_RUNIMAGE_INTERNAL_CONFIG=1
        fi
        if [ "$SET_RUNIMAGE_INTERNAL_CONFIG" == 1 ]
            then
                NO_NOTIFY=1 info_msg "Found RunImage internal config: $(basename "$RUNIMAGE_INTERNAL_CONFIG")"
                set -a
                source "$RUNIMAGE_INTERNAL_CONFIG"
                set +a
        fi
        if [[ -f "$RUNIMAGE_CONFIG" && -n "$(echo "$RUNIMAGE_CONFIG"|grep -o '\.rcfg$')" ]]
            then
                SET_RUNIMAGE_CONFIG=1
        elif [ -f "$RUNIMAGEDIR/$RUNSRCNAME.rcfg" ]
            then
                RUNIMAGE_CONFIG="$RUNIMAGEDIR/$RUNSRCNAME.rcfg"
                SET_RUNIMAGE_CONFIG=1
        elif [ -f "$RUNIMAGEDIR/config/$RUNSRCNAME.rcfg" ]
            then
                RUNIMAGE_CONFIG="$RUNIMAGEDIR/config/$RUNSRCNAME.rcfg"
                SET_RUNIMAGE_CONFIG=1
        elif [[ -n "$RUNIMAGE" && -f "$RUNIMAGE.rcfg" ]]
            then
                RUNIMAGE_CONFIG="$RUNIMAGE.rcfg"
                SET_RUNIMAGE_CONFIG=1
        elif [ -f "$RUNIMAGEDIR/Run.rcfg" ]
            then
                RUNIMAGE_CONFIG="$RUNIMAGEDIR/Run.rcfg"
                SET_RUNIMAGE_CONFIG=1
        elif [ -f "$RUNIMAGEDIR/config/Run.rcfg" ]
            then
                RUNIMAGE_CONFIG="$RUNIMAGEDIR/config/Run.rcfg"
                SET_RUNIMAGE_CONFIG=1
        fi
        if [ "$SET_RUNIMAGE_CONFIG" == 1 ]
            then
                info_msg "Found RunImage config: '$RUNIMAGE_CONFIG'"
                set -a
                source "$RUNIMAGE_CONFIG"
                set +a
        fi
    else
        warn_msg "RunImage config is disabled!"
fi

if logname &>/dev/null
    then
        export RUNUSER="$(logname)"
elif [ -n "$SUDO_USER" ]
    then
        export RUNUSER="$SUDO_USER"
elif [[ "$EUID" != 0 && "$USER" != "root" ]] || \
     [[ "$EUID" == 0 && "$USER" != "root" ]]
    then
        export RUNUSER="$USER"
elif [ -n "$(who|grep -m1 'tty'|awk '{print$1}')" ]
    then
        export RUNUSER="$(who|grep -m1 'tty'|awk '{print$1}')"
fi

if [[ "$DISPLAY" == "wayland-"* ]]
    then
        export DISPLAY=":$(echo "$DISPLAY"|sed 's|wayland-||g')"
elif [[ ! -n "$DISPLAY" && ! -n "$WAYLAND_DISPLAY" ]]
    then
        export DISPLAY="$(who|grep "$RUNUSER"|grep -v "ttyS"|\
                          grep -om1 '(.*)$'|sed 's/(//;s/)//')"
fi

xhost +si:localuser:$RUNUSER &>/dev/null
[[ "$EUID" == 0 && "$RUNUSER" != "root" ]] && \
    xhost +si:localuser:root &>/dev/null

[ "$SYS_TOOLS" == 1 ] && \
    export SYS_MKSQFS=1 SYS_UNSQFS=1 \
           SYS_SQFUSE=1 SYS_BWRAP=1 SYS_ARIA2C=1

if [ "$SYS_MKSQFS" == 1 ] && is_sys_exe mksquashfs
    then
        info_msg "The system mksquashfs is used!"
        export MKSQFS="$(which_sys_exe mksquashfs)"
    else
        export MKSQFS="$BINDIR/mksquashfs"
fi

if [ "$SYS_UNSQFS" == 1 ] && is_sys_exe unsquashfs
    then
        info_msg "The system unsquashfs is used!"
        export UNSQFS="$(which_sys_exe unsquashfs)"
    else
        export UNSQFS="$BINDIR/unsquashfs"
fi

if [ "$SYS_ARIA2C" == 1 ] && is_sys_exe aria2c
    then
        info_msg "The system aria2c is used!"
        export ARIA2C="$(which_sys_exe aria2c)"
    else
        export ARIA2C="$BINDIR/aria2c"
fi

if [ "$SYS_SQFUSE" == 1 ] && is_sys_exe squashfuse
    then
        info_msg "The system squashfuse is used!"
        export SQFUSE="$(which_sys_exe squashfuse)"
    else
        [ -x "$(which_sys_exe fusermount3)" ] && \
            export SQFUSE="$BINDIR/squashfuse3" || \
            export SQFUSE="$BINDIR/squashfuse"
fi

if [ "$EUID" != 0 ]
    then
        if [ ! -f '/proc/self/ns/user' ]
            then
                SYS_BWRAP=1
                [ ! -n "$(echo "$PATH"|grep -wo '^/usr/bin:')" ] && \
                    export PATH="/usr/bin:$PATH"
                if [ ! -x "$(find "$(which bwrap 2>/dev/null)" -perm -u=s 2>/dev/null)" ]
                    then
                        [ ! -x '/tmp/bwrap' ] && \
                            rm -rf '/tmp/bwrap' && \
                            cp "$BINDIR/bwrap" '/tmp/'
                        error_msg 'The kernel does not support user namespaces!'
                        if ! console_info_notify
                            then
                                echo -e "${YELLOW}\nYou need to install SUID Bubblewrap into the system:"
                                echo -e "${RED}# ${GREEN}sudo cp -f /tmp/bwrap /usr/bin/ && sudo chmod u+s /usr/bin/bwrap"
                                echo -e "${RED}\n[NOT RECOMMENDED]: ${YELLOW}Or run as the root user."
                                echo -e "${YELLOW}\nOr install a kernel with user namespaces support."
                                echo -e "[RECOMMENDED]: XanMod kernel -> ${BLUE}https://xanmod.org$RESETCOLOR"
                        fi
                        exit 1
                fi
        elif [ "$(cat '/proc/sys/kernel/unprivileged_userns_clone' 2>/dev/null)" == 0 ]
            then
                error_msg "unprivileged_userns_clone is disabled!"
                if ! console_info_notify
                    then
                        echo -e "${YELLOW}\nYou need to enable unprivileged_userns_clone:"
                        echo -e "${RED}# ${GREEN}sudo bash -c 'echo kernel.unprivileged_userns_clone=1 >> /etc/sysctl.d/98-userns.conf'"
                        echo -e "${RED}# ${GREEN}sudo bash -c 'echo 1 > /proc/sys/kernel/unprivileged_userns_clone'$RESETCOLOR"
                fi
                exit 1
        elif [ "$(cat '/proc/sys/user/max_user_namespaces' 2>/dev/null)" == 0 ]
            then
                error_msg "max_user_namespaces is disabled!"
                if ! console_info_notify
                    then
                        echo -e "${YELLOW}\nYou need to enable max_user_namespaces:"
                        echo -e "${RED}# ${GREEN}sudo bash -c 'echo user.max_user_namespaces=10000 >> /etc/sysctl.d/98-userns.conf'"
                        echo -e "${RED}# ${GREEN}sudo bash -c 'echo 10000 > /proc/sys/user/max_user_namespaces'$RESETCOLOR"
                fi
                exit 1
        elif [ "$(cat '/proc/sys/kernel/userns_restrict' 2>/dev/null)" == 1 ]
            then
                error_msg "userns_restrict is enabled!"
                if ! console_info_notify
                    then
                        echo -e "${YELLOW}\nYou need to disabled userns_restrict:"
                        echo -e "${RED}# ${GREEN}sudo bash -c 'echo kernel.userns_restrict=0 >> /etc/sysctl.d/98-userns.conf'"
                        echo -e "${RED}# ${GREEN}sudo bash -c 'echo 0 > /proc/sys/kernel/userns_restrict'$RESETCOLOR"
                fi
                exit 1
        fi
fi

if [ "$SYS_BWRAP" == 1 ] && is_sys_exe bwrap
    then
        info_msg "The system Bubblewrap is used!"
        export BWRAP="$(which_sys_exe bwrap)"
    else
        export BWRAP="$BINDIR/bwrap"
fi
if [[ "$SYS_BWRAP" == 1 && "$EUID" != 0 && \
      -x "$(find "$BWRAP" -perm -u=s 2>/dev/null)" ]]
    then
        warn_msg "Bubblewrap has SUID sticky bit!"
        SUID_BWRAP=1
fi
if [[ "$SUID_BWRAP" == 1 || "$NO_CAP" == 1 ]]
    then
        warn_msg "Bubblewrap capabilities is disabled!"
        BWRAP_CAP=("--cap-drop" "ALL")
fi

if sestatus &>/dev/null
    then
        [ "$(sestatus|grep mode|awk '{print$3}')" == "enforcing" ] && \
            warn_msg "SELinux in enforcing mode!"
fi

if [[ -n "$RUNOFFSET" && -n "$RUNIMAGE" ]] # MangoHud and vkBasalt bug in DXVK mode
    then
        export RUNMNT="/tmp/.mount_${RUNIMAGENAME}.$RUNKEY"
        export RUNROOTFS="$RUNMNT/rootfs"
        try_mkdir "$RUNMNT"
        "$SQFUSE" -f "$RUNIMAGE" "$RUNMNT" -o "ro,offset=$RUNOFFSET" &
        SQFUSE_PID="$!"
        export SQFUSE_PIDS="$SQFUSE_PID $SQFUSE_PIDS"
        if ! mount_exist "$SQFUSE_PID" "$RUNMNT"
            then
                error_msg "Failed to mount RunImage rootfs!"
                FORCE_CLEANUP=1 cleanup
                exit 1
        fi
fi

if [ -n "$AUTORUN" ]
    then
        AUTORUN0ARG=($AUTORUN)
        info_msg "Autorun mode: $AUTORUN"
        if [ ! -x "$RUNROOTFS/usr/bin/$AUTORUN0ARG" ]
            then
                error_msg "$AUTORUN0ARG not found in /usr/bin"
                FORCE_CLEANUP=1 cleanup
                exit 1
        fi
fi

[ -n "$HOME" ] && \
   SYS_HOME="$HOME"

if [[ "$TMP_HOME" == 1 || "$TMP_HOME_DL" == 1 ]]
    then
        [ "$EUID" == 0 ] && \
            export HOME="/root" || \
            export HOME="/home/$RUNUSER"
        HOME_BIND+=("--tmpfs" "/home" \
                    "--tmpfs" "/root" \
                    "--dir" "$HOME/.cache" \
                    "--dir" "$HOME/.config")
        [[ "$EUID" == 0 && "$RUNUSER" != "root" ]] && \
            HOME_BIND+=("--dir" "/home/$RUNUSER")
        [ "$TMP_HOME_DL" == 1 ] && \
            HOME_BIND+=("--dir" "$HOME/Downloads" \
                        "--symlink" "$HOME/Downloads" "$HOME/Загрузки" \
                        "--bind-try" "$HOME/Downloads" "$HOME/Downloads")
        info_msg "Setting temporary \$HOME to: '$HOME'"
    else
        if [[ -n "$SYS_HOME" && "$SYS_HOME" != "/root" && \
            "$(echo "$SYS_HOME"|head -c 6)" != "/home/" ]]
            then
                case "$(echo "$SYS_HOME"|cut -d '/' -f2)" in
                    tmp|mnt|media|run|dev|proc|sys) : ;;
                    *)
                        if [ "$EUID" == 0 ]
                            then
                                NEW_HOME="/root"
                                HOME_BIND+=("--bind-try" "/home" "/home")
                            else
                                NEW_HOME="/home/$RUNUSER"
                                HOME_BIND+=("--tmpfs" "/home" \
                                            "--tmpfs" "/root" \
                                            "--dir" "$NEW_HOME")
                        fi
                        HOME_BIND+=("--bind-try" "$SYS_HOME" "$NEW_HOME")
                        export HOME="$NEW_HOME"
                    ;;
                esac
            else
                HOME_BIND+=("--bind-try" "/home" "/home")
                if [ "$EUID" == 0 ]
                    then
                        if [ "$SYS_HOME" == "/home/$RUNUSER" ]
                            then
                                export HOME="/root"
                                SET_HOME_DIR=1
                        fi
                        HOME_BIND+=("--bind-try" "/root" "/root")
                    else
                        HOME_BIND+=("--tmpfs" "/root")
                fi
        fi
        if [ "$PORTABLE_HOME" != 0 ]
            then
                if [[ "$PORTABLE_HOME" == 1 || -d "$RUNIMAGEDIR/$RUNSRCNAME.home" ]]
                    then
                        export HOME="$RUNIMAGEDIR/$RUNSRCNAME.home"
                        SET_HOME_DIR=1
                elif [ -n "$RUNIMAGE" ] && [[ "$PORTABLE_HOME" == 1 || -d "$RUNIMAGE.home" ]]
                    then
                        export HOME="$RUNIMAGE.home"
                        SET_HOME_DIR=1
                elif [[ "$PORTABLE_HOME" == 1 || -d "$RUNIMAGEDIR/Run.home" ]]
                    then
                        export HOME="$RUNIMAGEDIR/Run.home"
                        SET_HOME_DIR=1
                fi
        fi
fi
if [[ -L "$HOME" && ! -n "$NEW_HOME" && "$HOME" != "/root" ]]
    then
        export HOME="$(realpath "$HOME" 2>/dev/null)"
        warn_msg "Symlinking for \$HOME is not allowed!"
        SET_HOME_DIR=1
fi
if [ "$SET_HOME_DIR" == 1 ]
    then
        try_mkdir "$HOME"
        try_mkdir "$HOME/.cache"
        try_mkdir "$HOME/.config"
        info_msg "Setting \$HOME to: '$HOME'"
fi

if [ "$PORTABLE_CONFIG" != 0 ]
    then
        if [[ "$PORTABLE_CONFIG" == 1 || -d "$RUNIMAGEDIR/$RUNSRCNAME.config" ]]
            then
                export XDG_CONFIG_HOME="$RUNIMAGEDIR/$RUNSRCNAME.config"
                SET_CONF_DIR=1
        elif [ -n "$RUNIMAGE" ] && [[ "$PORTABLE_CONFIG" == 1 || -d "$RUNIMAGE.config" ]]
            then
                export XDG_CONFIG_HOME="$RUNIMAGE.config"
                SET_CONF_DIR=1
        elif [[ "$PORTABLE_CONFIG" == 1 || -d "$RUNIMAGEDIR/Run.config" ]]
            then
                export XDG_CONFIG_HOME="$RUNIMAGEDIR/Run.config"
                SET_CONF_DIR=1
        fi
fi
if [ "$SET_CONF_DIR" == 1 ]
    then
        try_mkdir "$XDG_CONFIG_HOME"
        info_msg "Setting \$XDG_CONFIG_HOME to: '$XDG_CONFIG_HOME'"
fi

[ -n "$XAUTHORITY" ] && \
    SYS_XAUTHORITY="$XAUTHORITY"

if [[ ! -n "$XAUTHORITY" || "$SET_HOME_DIR" == 1 || \
    "$TMP_HOME" == 1 || "$TMP_HOME_DL" == 1 ]]
    then
        export XAUTHORITY="$HOME/.Xauthority"
        if [ -n "$SYS_XAUTHORITY" ]
            then
                HOME_BIND+=("--bind-try" "$SYS_XAUTHORITY" "$XAUTHORITY")
            else
                if [[ "$EUID" == 0 && "$RUNUSER" == "root" ]]
                    then
                        HOME_BIND+=("--bind-try" "/root/.Xauthority" "$XAUTHORITY")
                elif [[ "$EUID" == 0 && "$RUNUSER" != "root" ]]
                    then
                        HOME_BIND+=("--ro-bind-try" "/home/$RUNUSER/.Xauthority" "$XAUTHORITY")
                else
                    HOME_BIND+=("--bind-try" "/home/$RUNUSER/.Xauthority" "$XAUTHORITY")
                fi
        fi
fi

if [[ ! -n "$XDG_RUNTIME_DIR" || "$XDG_RUNTIME_DIR" != "/run/user/$EUID" || "$UNSHARE_PIDS" == 1 ]]
    then
        export XDG_RUNTIME_DIR="/run/user/$EUID"
        if [[ "$UNSHARE_PIDS" == 1 || ! -d "$XDG_RUNTIME_DIR" ]]
            then
                XDG_RUN_BIND+=("--tmpfs" "/run" \
                               "--dir" "$XDG_RUNTIME_DIR" \
                               "--chmod" "0700" "$XDG_RUNTIME_DIR")
                if [ ! -d "$XDG_RUNTIME_DIR" ]
                    then
                        for i_run in /run/* /run/.[a-zA-Z0-9]*
                            do
                                [ "$i_run" != "/run/user" ] && \
                                    XDG_RUN_BIND+=("--bind-try" "$i_run" "$i_run")
                        done
                fi
                if [ "$UNSHARE_PIDS" == 1 ]
                    then
                        warn_msg "System PIDs hiding enabled!"
                        UNPIDS_BIND+=("--as-pid-1" \
                                      "--unshare-pid" \
                                      "--bind-try" "$XDG_RUNTIME_DIR/pulse" "$XDG_RUNTIME_DIR/pulse" \
                                      "--bind-try" "$XDG_RUNTIME_DIR/pipewire-0" "$XDG_RUNTIME_DIR/pipewire-0")
                        EXEC_ARGS=("dbus-launch" "--exit-with-session")
                fi
            else
                XDG_RUN_BIND=("--bind-try" "/run" "/run")
        fi
    else
        XDG_RUN_BIND=("--bind-try" "/run" "/run")
fi

[[ ! -n "$DBUS_SESSION_BUS_ADDRESS" && -S "$XDG_RUNTIME_DIR/bus" ]] && \
    export DBUS_SESSION_BUS_ADDRESS="unix:path=$XDG_RUNTIME_DIR/bus"

if [ -d "/tmp/.X11-unix" ] # Gamecope X11 sockets bug
    then
        if [ -L "/tmp/.X11-unix" ] # WSL
            then
                TMP_BIND+=("--tmpfs" "/tmp" \
                           "--dir" "/tmp/.X11-unix")
                for i_tmp in /tmp/* /tmp/.[a-zA-Z0-9]*
                    do
                        [ "$i_tmp" != "/tmp/.X11-unix" ] && \
                            TMP_BIND+=("--bind-try" "$i_tmp" "$i_tmp")
                done
            else
                TMP_BIND+=("--bind-try" "/tmp" "/tmp" \
                           "--tmpfs" "/tmp/.X11-unix")
        fi
        if [ -n "$(ls -A /tmp/.X11-unix 2>/dev/null)" ]
            then
                for x_socket in /tmp/.X11-unix/X*
                    do
                        TMP_BIND+=("--bind-try" "$x_socket" "$x_socket")
                done
        fi
    else
        TMP_BIND+=("--bind-try" "/tmp" "/tmp")
fi

if [ -d "$TMPDIR" ]
    then
        NEWTMPDIR="/tmp/.TMPDIR"
        info_msg "Binding \$TMPDIR to: '$NEWTMPDIR'"
        TMPDIR_BIND+=("--dir" "$NEWTMPDIR" \
                      "--bind-try" "$TMPDIR" "$NEWTMPDIR" \
                      "--setenv" "TMPDIR" "$NEWTMPDIR")
    else
        unset TMPDIR
fi

if [ "$NO_INET" == 1 ]
    then
        NETWORK_BIND+=("--unshare-net")
        warn_msg "Network is disabled!"
    else
        NETWORK_BIND+=("--share-net" \
                       "--ro-bind-try" "/etc/hosts" "/etc/hosts" \
                       "--ro-bind-try" "/etc/resolv.conf" "/etc/resolv.conf")
fi

if [ "$XORG_CONF" != 0 ]
    then
        if [[ -f "$XORG_CONF" && "$(basename "$XORG_CONF")" == "xorg.conf" ]]
            then
                info_msg "Found xorg.conf in: '$XORG_CONF'"
                XORG_CONF_BIND=("--ro-bind-try" \
                                "$XORG_CONF" "/etc/X11/xorg.conf")
        elif [ -f "/etc/X11/xorg.conf" ]
            then
                info_msg "Found xorg.conf in: '/etc/X11/xorg.conf'"
                XORG_CONF_BIND=("--ro-bind-try" \
                                "/etc/X11/xorg.conf" "/etc/X11/xorg.conf")
        fi
    else
        warn_msg "Binding xorg.conf is disabled!"
fi

add_bin_pth "$HOME/.local/bin:/bin:/sbin:/usr/bin:/usr/sbin:\
/usr/lib/jvm/default/bin:/usr/local/bin:/usr/local/sbin:$SYS_PATH"
[ -n "$LD_LIBRARY_PATH" ] && \
    add_lib_pth "$LD_LIBRARY_PATH"

[ "$NO_NVIDIA_CHECK" != 1 ] && \
    check_nvidia_driver || \
    warn_msg "Nvidia driver check is disabled!"

[ "$ADD_LD_CACHE" == 1 ] && \
    LD_CACHE_BIND=("--bind-try" \
                   "$RUNCACHEDIR/ld.so.cache" "/etc/ld.so.cache")
##############################################################################
if [ -n "$AUTORUN" ]
    then
        bwrun /usr/bin/$AUTORUN "$@"
    else
        if [ ! -n "$1" ]
            then
                print_help
            else
                case $1 in
                    --runimage-help) print_help ;;
                    --runimage-bwraphelp) bwrap_help ;;
                    --runimage-pkglist) pkg_list ;;
                    --runimage-binlist) bin_list ;;
                    --runimage-shell) shift && bwrun /usr/bin/fish "$@" ;;
                    --runimage-desktop) bwrun /usr/bin/rundesktop ;;
                    --runimage-version) print_version ;;
                    *) bwrun "$@" ;;
                esac
        fi
fi
EXEC_STATUS="$?"
cleanup
exit $EXEC_STATUS
##############################################################################
